#pragma safe
class File;

external classtype;

use FileSystem: { TheFileSystem };
use String: { string };
use SysErr: { syserr };

export all;

/******************************************************************************
 *
 * Functions to open and close files.
 *
 ******************************************************************************/

external syserr, File fopen(string NAME, string MODE);
    #pragma effect TheFileSystem
    #pragma linkobj "src/File/fopen.o"
    #pragma linkname "SACfopen"
    #pragma linksign [0,1,2,3]
    /*
     * Open the file NAME in mode MODE. The modes supported are identical
     * to the C version of this function. An error condition and a file
     * handle are returned. You should inspect the error condition before
     * using the file handle.
     */

external syserr, File, string mkstemp(string template);
    #pragma effect TheFileSystem
    #pragma linkobj "src/File/mkstemp.o"
    #pragma linkname "SACmkstemp"
    #pragma linksign [0,1,2,3]
    #pragma refcounting [2]
    /*
     * Create a temporary file using a name generated by the function
     * mkstemp, and returns the corresponding file handle. The file is
     * opened for update ("w+"). An error condition is
     * returned as well. You should inspect the error condition before
     * using the file handle.
     * The name of the resulting file is derived from the template
     * argument. It should look like a file name with six trailing 'X's.
     * Each X is then replaced by a character from the portable file
     * name character set. The characters are chosen such that the
     * resulting name does not duplicate the name of an existing file.
     */

syserr, File, string tmpfile()
{
    err, file, name = mkstemp("TMP_XXXXXX");
    return(err, file, name);
}
    /*
     * Create a temporary file using a name generated by the function
     * mkstemp, and returns the corresponding file handle. The file is
     * opened for update ("w+"). An error condition is
     * returned as well. You should inspect the error condition before
     * using the file handle.
     */

external void fclose(File STREAM);
    #pragma effect TheFileSystem
    #pragma linkobj "src/File/fclose.o"
    #pragma linkname "SACfclose"
    /*
     * Close the stream given by the file handle STREAM.
     */

external void fremove(string fname);
    #pragma effect TheFileSystem
    #pragma linkobj "src/File/rm.o"
    /*
     * Remove file or directory.
     */

/******************************************************************************
 *
 * Functions for low-level input / output operations.
 *
 ******************************************************************************/

external void fputc(char C, File &STREAM);
    #pragma linkobj "src/File/fputc.o"
    #pragma linkname "SACfputc"
    /*
     * Write the character C to the output stream STREAM.
     */

external char fgetc(File &STREAM);
    #pragma linkobj "src/File/fgetc.o"
    #pragma linkname "SACfgetc"
    #pragma linksign [0,1]
    /*
     * Get the next character from the input stream STREAM.
     */

external void ungetc(char C, File &STREAM);
    #pragma linkobj "src/File/ungetc.o"
    #pragma linkname "SACungetc"
    /*
     * Put the character C back to the input stream STREAM for further
     * read operations. Only one character may be put back between two
     * consecutive read operations, otherwise the character put back first
     * is overwritten.
     */

external void fputs(string S, File &STREAM);
    #pragma linkobj "src/File/fputs.o"
    #pragma linkname "SACfputs"
    /*
     * Write string S to stream.
     */

/******************************************************************************
 *
 * Functions for formatted input / output operations.
 *
 ******************************************************************************/

external void fprintf(File &STREAM, string FORMAT, ...);
    #pragma linkobj "src/File/fprintf.o"
    #pragma linkname "SACfprintf"
    /*
     * Print formatted output to STREAM which must be open for writing.
     * The syntax of format strings is identical to that known from C.
     * This function may be used to print values of types
     * char, string, int, float, and double.
     */

external int, ... fscanf(File &STREAM, string FORMAT);
    #pragma linkobj "src/File/fscanf.o"
    #pragma linkname "SACfscanf"
    #pragma linksign [0,1,2]
    /*
     * Scan the given stream STREAM concerning the format string FORMAT.
     * The syntax of format strings is identical to C except that the
     * string conversion specifier %s is not supported.
     * This function may be used to scan values of types
     * char, int, float, and double. To scan strings use either fscans
     * or fscanl, respectively.
     * The int result gives the number of successfully performed
     * conversions.
     */

external string fscans(File &STREAM, int MAX);
    #pragma linkobj "src/File/fscans.o"
    #pragma linksign [0,1,2]
    /*
     * Read the next character string from the input stream STREAM. Strings
     * are delimited by any whitespace character including the
     * end-of-file symbol. Always read at most MAX characters.
     * Upon failure an empty string is returned.
     */

external string fscanl(File &STREAM, int MAX);
    #pragma linkobj "src/File/fscanl.o"
    #pragma linksign [0,1,2]
    /*
     * Read the next line from the input stream STREAM. Lines are character
     * strings delimited by any new-line or end-of-file symbol.
     * Always read at most MAX characters.
     * Upon failure an empty string is returned.
     */

/******************************************************************************
 *
 * Functions for managing file-bound I/O-streams.
 *
 ******************************************************************************/

external bool feof(File &STREAM);
    #pragma linkobj "src/File/feof.o"
    #pragma linkname "SACfeof"
    #pragma linksign [0,1]
    /*
     * Test the stream STREAM for having reached the end of the respective file.
     */

external void fflush(File &STREAM);
    #pragma linkobj "src/File/fflush.o"
    #pragma linkname "SACfflush"
    /*
     * Write the buffer of a buffered output stream STREAM
     * to the respective file.
     */

external void fseek(File &STREAM, int OFFSET, int BASE);
    #pragma linkobj "src/File/fseek.o"
    #pragma linkname "SACfseek"
    /*
     * Reposition the stream STREAM. The new position is given as an offset
     * in bytes relative to BASE which may be 0 (beginning of file),
     * 1 (current position), or 2 (end of file).
     */

external int ftell(File &STREAM);
    #pragma linkobj "src/File/ftell.o"
    #pragma linkname "SACftell"
    #pragma linksign [0,1]
    /*
     * Return the offset of the current byte relative to
     * the beginning of the file associated with STREAM.
     */

external void rewind(File &STREAM);
    #pragma linkobj "src/File/rewind.o"
    #pragma linkname "SACrewind"
    /*
     * Reposition the stream STREAM to the beginning of the file associated
     * with it (identical to fseek(<stream>, 0, 0)).
     */
