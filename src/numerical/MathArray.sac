#pragma safe
module MathArray;

export all except { + };

/******************************************************************************
 *
 * This module provides float[*] and double[*] variants
 * of the math operations from Math.sac.
 *
 * Namely, these are:
 *   log, log2, log10, exp, fabs, sqrt, floor, pow
 *
 ******************************************************************************/

#define MAP_A(op, typ)                                                         \
inline typ[d>0:shp] op(typ[d>0:shp] arr)                                       \
{                                                                              \
    return { iv -> Math::op(_sel_VxA_(iv, arr)) | iv < shp };                  \
}

#define MAP_AxS(op, typ)                                                       \
inline typ[d>0:shp] op(typ[d>0:shp] arr, typ x)                                \
{                                                                              \
    return { iv -> Math::op(_sel_VxA_(iv, arr), x) | iv < shp };               \
}

#define MAP_REAL(fun, op)                                                      \
fun(op, float)                                                                 \
fun(op, double)

MAP_REAL(MAP_A, log)
MAP_REAL(MAP_A, log2)
MAP_REAL(MAP_A, log10)
MAP_REAL(MAP_A, exp)
MAP_REAL(MAP_A, fabs)
MAP_REAL(MAP_A, sqrt)
MAP_REAL(MAP_A, floor)
MAP_REAL(MAP_AxS, pow)

/******************************************************************************
 *
 * L2-norm
 *
 ******************************************************************************/

inline float +(float a, float b) { return _add_SxS_(a, b); }
inline float l2norm(float[d:shp] a)
{
    return Math::sqrt(with {
        (_mul_SxV_(0, shp) <= iv < shp)
            : _mul_SxS_(_sel_VxA_(iv, a), _sel_VxA_(iv, a));
    } : fold(+, 0f));
}

inline double +(double a, double b) { return _add_SxS_(a, b); }
inline double l2norm(double[d:shp] a)
{
    return Math::sqrt(with {
        (_mul_SxV_(0, shp) <= iv < shp)
            : _mul_SxS_(_sel_VxA_(iv, a), _sel_VxA_(iv, a));
    } : fold(+, 0d));
}
