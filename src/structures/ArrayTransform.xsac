module ArrayTransform;

 /******************************************************************************
 *
 * Depends on ScalarArith, ArrayBasics, and Constants.
 *
 ******************************************************************************/

use ArrayBasics: { sel, genarray };
use Constants: all;

export all;

#include "Templates.mac"

 /******************************************************************************
 *
 * @fn <a>[o:sv,i:ishp] take(int[o] sv, typ[o:ohsp,i:ishp] A)
 *
 * @brief Takes a number of elements from the array, given a shape vector.
 *
 * @remark Take does NOT support overtake
 *         E.g., take([5], [2, 3]) throws an error.
 *
 * @remark Take supports negative sv, taking the last elements
 *         E.g., take([-1], [2, 3]) =
 *           [3]
 *
 * @remark Take supports lower-dimensional sv, padding the missing elements
 *         with corresponding elements from shp.
 *         E.g., take([1], genarray([2,2], 42)) =
 *           [[42, 42]]
 *
 ******************************************************************************/

#define TAKE(typ, postfix, zval, oval)                                         \
inline                                                                         \
typ[o:sv,i:ishp] take(int[o] sv, typ[o:oshp,i:ishp] A)                         \
    | _all_V_(_le_VxV_(_abs_V_(sv), oshp))                                     \
{                                                                              \
    /* Start shows the index of the first element to be selected. */           \
    start = where(_lt_VxS_(sv, 0),                                             \
                  _add_VxV_(oshp, sv),                                         \
                  0);                                                          \
    /* Stop signals the location of the last index element of array. */        \
    stop = _abs_V_(sv);                                                        \
    return { iv -> A[_add_VxV_(start, iv)] | iv < stop };                      \
}

BUILT_IN(TAKE)

/******************************************************************************
 *
 * @fn <a>[o:sv,i:ishp] take_apl(int[o] sv, <a>[o:oshp,i:ishp] A)
 *
 * @brief Takes a number of elements from the array in APL style,
 *        given a shape vector.
 *
 * @remark take_apl supports overtake
 *         E.g., take([5], [2, 3]) =
 *           [2, 3, 0, 0, 0]
 *
 * @remark take_apl supports negative sv, taking the last elements
 *         E.g., take([-1], [2, 3]) =
 *           [3]
 *         E.g., take([-5], [2, 3]) =
 *           [0, 0, 0, 2, 3]
 *
 * @remark take_apl supports lower-dimensional sv, padding the missing elements
 *         with corresponding elements from shp.
 *         E.g., take([3], genarray([2,2], 42)) =
 *           [[42, 42]
 *            [42, 42]
 *            [0,  0]]
 *
 ******************************************************************************/

#define TAKE_APL(typ, postfix, zval, oval)                                     \
inline                                                                         \
typ[o:sv,i:ishp] take_apl(int[o] sv, typ[o:oshp,i:ishp] A)                     \
{                                                                              \
    /* Offset shows the index of the first element to be selected. */          \
    offset = where(_lt_VxS_(sv, 0),                                            \
                   _add_VxV_(oshp, sv),                                        \
                   0);                                                         \
    /* Stop signals the location of the last index element of array.           \
     * This can be longer than the size of the array, in case offset           \
     * is less than (-oshp). */                                                \
    stop = where(_lt_VxS_(sv, 0),                                              \
                 _abs_V_(sv),                                                  \
                 _min_VxV_(_abs_V_(sv), oshp));                                \
    /* Start shows where the selection of array elements starts.               \
     * This can only be different from offset if offset < (-oshp). */          \
    start = _max_VxS_(_neg_V_(offset), 0);                                     \
    /* The result is calculated in 2 steps: */                                 \
    return { /* 1: select the required elements of the array */                \
             iv -> A[_add_VxV_(offset, iv)] | start <= iv < stop;              \
             /* 2: add zeros around (if needed) */                             \
             iv -> genarray(ishp, zval) | iv < _abs_V_(sv) };                  \
}

BUILT_IN(TAKE_APL)

/******************************************************************************
 *
 * @fn <a>[o:shp_res,i:ishp] drop(int[o] sv, <a>[o:oshp,i:ishp] A)
 *
 * @brief Drops a number of elements from the array in APL style,
 *        given a shape vector.
 *
 * @remark drop does NOT support overdrop
 *         E.g., drop([5], [2, 3]) throws an error.
 *
 * @remark drop_apl supports negative sv, dropping the last elements
 *         E.g., drop([-1], [2, 3]) =
 *           [2]
 *
 * @remark drop_apl supports lower-dimensional sv, padding the missing elements
 *         with corresponding elements from shp.
 *         E.g., drop([1], genarray([2,2], 42)) =
 *           [[42, 42]]
 *
 ******************************************************************************/

#define DROP(typ, postfix, zval, oval)                                         \
inline                                                                         \
typ[o:shp_res,i:ishp] drop(int[o] sv, typ[o:oshp,i:ishp] A)                    \
    | _all_V_(_le_VxV_(_abs_V_(sv), oshp))                                     \
{                                                                              \
    /* Calculate shape of result array. */                                     \
    shp_res = _sub_VxV_(oshp, _abs_V_(sv));                                    \
    /* Start shows the index of the first element to be selected. */           \
    start = _max_VxS_(sv, 0);                                                  \
    return { iv -> A[_add_VxV_(start, iv)] | iv < shp_res };                   \
}

BUILT_IN(DROP)

/******************************************************************************
 *
 * @fn <a>[o:shp_res,i:ishp] drop_apl(int[o] sv, <a>[o:oshp,i:ishp] A)
 *
 * @brief Drops a number of elements from the array in APL style,
 *        given a shape vector.
 *
 * @remark drop_apl supports overdrop
 *         E.g., drop([5], [2, 3]) =
 *           []
 *
 * @remark drop_apl supports negative sv, dropping the last elements
 *         E.g., drop([-1], [2, 3]) =
 *           [2]
 *
 * @remark drop_apl supports lower-dimensional sv, padding the missing elements
 *         with corresponding elements from shp.
 *         E.g., drop([1], genarray([2,2], 42)) =
 *           [[42, 42]]
 *
 ******************************************************************************/

#define DROP_APL(typ, postfix, zval, oval)                                     \
inline                                                                         \
typ[o:shp_res,i:ishp] drop_apl(int[o] sv, typ[o:oshp,i:ishp] A)                \
{                                                                              \
    /* Calculate shape of result array. */                                     \
    shp_res = _sub_VxV_(oshp, _abs_V_(sv));                                    \
    shp_res = _max_VxS_(shp_res, 0);                                           \
    /* Start shows the index of the first element to be selected. */           \
    start = _max_VxS_(sv, 0);                                                  \
    /* Select the requested elements of array A. */                            \
    return { iv -> A[_add_VxV_(start, iv)] | iv < shp_res };                   \
}

BUILT_IN(DROP_APL)

/******************************************************************************
 *
 * @fn <a>[d:shp] tile(int[d] shp, int[d] idx, <a>[d:shp_a] A)
 *
 * @brief Takes a tile from the array, of shape shp, starting at index idx.
 *
 * @remark tile_apl does NOT support overtile
 *         E.g., tile([5], [1], [2, 3, 4]) throws an error.
 *
 ******************************************************************************/

#define TILE(typ, postfix, zval, oval)                                         \
inline                                                                         \
typ[d:shp] tile(int[d] shp, int[d] idx, typ[d:shp_a] A)                        \
    | _all_V_(_ge_VxS_(shp, 0))                                                \
    , _all_V_(_ge_VxS_(idx, 0))                                                \
    , _all_V_(_le_VxV_(_add_VxV_(shp, idx), shp_a))                            \
{                                                                              \
    return { iv -> _sel_VxA_(_add_VxV_(idx, iv), A) | iv < shp };              \
}

BUILT_IN(TILE)

/******************************************************************************
 *
 * @fn <a>[d:shp] tile_apl(int[d] shp, int[d] idx, <a>[d:shp_a] A)
 *
 * @brief Takes a tile from the array, of shape shp, starting at index idx.
 *
 * @remark tile_apl supports overtile
 *         E.g., tile([5], [1], [2, 3, 4]) =
 *           [3, 4, 0, 0, 0]
 *
 ******************************************************************************/

#define TILE_APL(typ, postfix, zval, oval)                                     \
inline                                                                         \
typ[d:shp] tile_apl(int[d] shp, int[d] idx, typ[d:shp_a] A)                    \
    | _all_V_(_ge_VxS_(shp, 0))                                                \
{                                                                              \
    /* Start shows how many elements we prepend before the array. */           \
    start = _max_VxS_(_neg_V_(idx), 0);                                        \
    /*                                                                         \
     * Stop shows where our selection of the given array ends, or, in case     \
     * the selection goes beyond the array, where the array ends.              \
     */                                                                        \
    stop = _min_VxV_(shp, _sub_VxV_(shp_a, idx));                              \
    /* The result is calculated in 2 steps: */                                 \
    return { /* 1: select the required elements of the array */                \
             iv -> _sel_VxA_(_add_VxV_(idx, iv), A) | start <= iv < stop;      \
             /* 2: add zeros around (if needed) */                             \
             iv -> zval | iv < shp};                                           \
}

BUILT_IN(TILE_APL)

/******************************************************************************
 *
 * @fn <a>[o,d:shp] ++(<a>[n,d:shp] A, <a>[m,d:shp] B)
 *
 * @brief First-axis catenation.
 *
 ******************************************************************************/

#define CAT_AxA(typ, postfix, zval, oval)                                      \
inline                                                                         \
typ[o,d:shp] ++(typ[n,d:shp] A, typ[m,d:shp] B)                                \
    | _eq_SxS_(o, _add_SxS_(n, m))                                             \
{                                                                              \
    o = _add_SxS_(n, m);                                                       \
    return { [i] -> A[i] | [i] < [n];                                          \
             [i] -> B[_sub_SxS_(i, n)] | [n] <= [i] < [o] };                   \
}

#define CAT(typ, postfix, zval, oval)                                          \
CAT_AxA(typ, postfix, zval, oval)

BUILT_IN(CAT)

/******************************************************************************
 *
 * @fn <a>[d:shp,o] ++^(<a>[d:shp,n] A, <a>[d:shp,m] B)
 *
 * @brief Last-axis catenation. We assume that A and B are the same shape,
 * except perhaps along the last axis.
 *
 ******************************************************************************/

#define CATENATE_AxA(typ, postfix, zval, oval)                                 \
inline                                                                         \
typ[d:shp,o] ++^(typ[d:shp,n] A, typ[d:shp,m] B)                               \
    | _eq_SxS_(o, _add_SxS_(n, m))                                             \
{                                                                              \
    return { iv -> _cat_VxV_(A[iv], B[iv]) | iv < shp };                       \
}

#define CATENATE(typ, postfix, zval, oval)                                     \
CATENATE_AxA(typ, postfix, zval, oval)

BUILT_IN(CATENATE)

/******************************************************************************
 *
 * @fn <a>[n,d:shp] reverse(<a>[n,d:shp] A)
 *
 * @brief First-axis reverse.
 *
 ******************************************************************************/

#define REVERSE(typ, postfix, zval, oval)                                      \
inline                                                                         \
typ[n,d:shp] reverse(typ[n,d:shp] A)                                           \
{                                                                              \
    return { [i] -> A[_sub_SxS_(_sub_SxS_(n, 1), i)] | [i] < [n] };            \
}

BUILT_IN(REVERSE)

/******************************************************************************
 *
 * @fn <a>[axis:oshp,n,i:ishp] reverse(int axis, <a>[axis:oshp,n,i:ishp] A)
 *
 * @brief Reverse on specified axis: 0 is leading axis, dim-1 is trailing axis.
 *
 ******************************************************************************/

#define REVERSEAXIS(typ, postfix, zval, oval)                                  \
inline                                                                         \
typ[axis:oshp,n,i:ishp] reverse(int axis, typ[axis:oshp,n,i:ishp] A)           \
{                                                                              \
    return { iv -> reverse(A[iv]) | iv < oshp };                               \
}

BUILT_IN(REVERSEAXIS)

/******************************************************************************
 *
 * @fn <a>[d:shp_t] transpose(<a>[d:shp] A)
 *
 * @brief transposes the given array.
 *
 ******************************************************************************/

#define TRANSPOSE(typ, postfix, zval, oval)                                    \
inline                                                                         \
typ[d:shp_t] transpose(typ[d:shp] A)                                           \
    | _all_V_(_eq_VxV_(reverse(shp), shp_t))                                   \
{                                                                              \
    shp_t = reverse(shp);                                                      \
    return { iv -> _sel_VxA_(reverse(iv), A) | iv < shp_t };                   \
}

BUILT_IN(TRANSPOSE)

/******************************************************************************
 *
 * @fn <a>[o:oshp,n,i:ishp] shift(int o, int count, <a> boundary,
 *                                <a>[o:oshp,n,i:ishp] A)
 *
 * @brief shifts the given array. Positive shift is to right, negative to left.
 *
 ******************************************************************************/

#define SHIFT_S(typ, postfix, zval, oval)                                      \
inline                                                                         \
typ[o:oshp,n,i:ishp] shift(int o, int count, typ boundary,                     \
                           typ[o:oshp,n,i:ishp] A)                             \
{                                                                              \
    return { iv ->                                                             \
            { [j] -> _and_SxS_(_lt_SxS_(_sub_SxS_(j, count), n),               \
                               _ge_SxS_(_sub_SxS_(j, count), 0))               \
                     ? A[_cat_VxV_(iv, [_sub_SxS_(j, count)])]                 \
                     : genarray(ishp, boundary)                                \
            | [j] < [n] }                                                      \
           | iv < oshp };                                                      \
}

#define SHIFT_V(typ, postfix, zval, oval)                                      \
inline                                                                         \
typ[o:oshp,i:ishp] shift(int[o] counts, typ boundary, typ[o:oshp,i:ishp] A)    \
{                                                                              \
    counts_ext = _cat_VxV_(counts, _mul_SxV_(0, ishp));                        \
    shp = _cat_VxV_(oshp, ishp);                                               \
    idx = _neg_V_(counts_ext);                                                 \
    return tile_apl(shp, idx, A);                                              \
}

#define SHIFT_VZ(typ, postfix, zval, oval)                                     \
inline                                                                         \
typ[o:oshp,i:ishp] shift(int[o] counts, typ[o:oshp,i:ishp] A)                  \
{                                                                              \
    return shift(counts, zval, A);                                             \
}

#define SHIFT(typ, postfix, zval, oval)                                        \
SHIFT_S(typ, postfix, zval, oval)                                              \
SHIFT_V(typ, postfix, zval, oval)                                              \
SHIFT_VZ(typ, postfix, zval, oval)

BUILT_IN(SHIFT)

/******************************************************************************
 *
 * @fn <a>[o:oshp,n,i:ishp] rotate(int o, int count, <a>[o:oshp,n,i:ishp] A)
 *
 * @brief Rotates the given array, wrapping values that go out of bounds.
 * Positive rotate is to right, negative to left.
 *
 * @example rotate([2], iota(5)) = [3, 4, 0, 1, 2]
 *
 ******************************************************************************/

#define ROTATE_S(typ, postfix, zval, oval)                                     \
inline                                                                         \
typ[o:oshp,n,i:ishp] rotate(int o, int count, typ[o:oshp,n,i:ishp] A)          \
{                                                                              \
    return { iv ->                                                             \
            { [j] ->                                                           \
                A[_cat_VxV_(iv, [_aplmod_SxS_(_sub_SxS_(j, count), n)])]       \
            | [j] < [n] }                                                      \
           | iv < oshp };                                                      \
}

#define ROTATE_V(typ, postfix, zval, oval)                                     \
inline                                                                         \
typ[n:oshp,i:ishp] rotate(int[n] counts, typ[n:oshp,i:ishp] A)                 \
{                                                                              \
  return { iv ->                                                               \
      A[{ [i] -> _aplmod_SxS_(_sub_SxS_(iv[i], counts[i]), oshp[i])            \
         | [i] < [n] } ]                                                       \
    | iv < oshp };                                                             \
}

#define ROTATE(typ, postfix, zval, oval)                                       \
ROTATE_S(typ, postfix, zval, oval)                                             \
ROTATE_V(typ, postfix, zval, oval)

BUILT_IN(ROTATE)

/******************************************************************************
 *
 * @fn <a>[d:shp] where(bool[d:shp] p, <a>[d:shp] A, <a>[d:shp] B)
 *
 * @brief Selects the element from A if the corresponding value of p is true,
 * otherwise selects the element from B.
 *
 ******************************************************************************/

#define WHERE_AxA(typ, postfix, zval, oval)                                    \
inline                                                                         \
typ[d:shp] where(bool[d:shp] p, typ[d:shp] A, typ[d:shp] B)                    \
{                                                                              \
    return { iv -> _sel_VxA_(iv, p) ? _sel_VxA_(iv, A) : _sel_VxA_(iv, B) };   \
}

#define WHERE_AxS(typ, postfix, zval, oval)                                    \
inline                                                                         \
typ[d:shp] where(bool[d:shp] p, typ[d:shp] A, typ B)                           \
{                                                                              \
    return { iv -> _sel_VxA_(iv, p) ? _sel_VxA_(iv, A) : B };                  \
}

#define WHERE_SxA(typ, postfix, zval, oval)                                    \
inline                                                                         \
typ[d:shp] where(bool[d:shp] p, typ A, typ[d:shp] B)                           \
{                                                                              \
    return { iv -> _sel_VxA_(iv, p) ? A : _sel_VxA_(iv, B) };                  \
}

#define WHERE_SxS(typ, postfix, zval, oval)                                    \
inline                                                                         \
typ[b:shp] where(bool[b:shp] p, typ A, typ B)                                  \
{                                                                              \
    return { iv -> _sel_VxA_(iv, p) ? A : B };                                 \
}

#define WHERE(typ, postfix, zval, oval)                                        \
WHERE_AxA(typ, postfix, zval, oval)                                            \
WHERE_AxS(typ, postfix, zval, oval)                                            \
WHERE_SxA(typ, postfix, zval, oval)                                            \
WHERE_SxS(typ, postfix, zval, oval)

BUILT_IN(WHERE)

/******************************************************************************
 *
 * @fn <a> reduce(<a>[d:shp] A)
 *
 * @brief Reduces the given array to a single element.
 *
 ******************************************************************************/

#define REDUCE(name, typ, fun, neutral)                                        \
inline                                                                         \
typ name(typ[d:shp] A)                                                         \
{                                                                              \
    return with {                                                              \
        (_mul_SxV_(0, shp) <= iv < shp) : _sel_VxA_(iv, A);                    \
    } : fold(fun, neutral);                                                    \
}

#define NUM_REDUCE(typ, postfix, zval, oval)                                   \
REDUCE(sum, typ, ScalarArith::+, zval)                                         \
REDUCE(prod, typ, ScalarArith::*, oval)                                        \
REDUCE(maxval, typ, ScalarArith::max, min##typ())                              \
REDUCE(minval, typ, ScalarArith::min, max##typ())

NUM(NUM_REDUCE)

#define BOOL_REDUCE                                                            \
REDUCE(all, bool, ScalarArith::&, true)                                        \
REDUCE(any, bool, ScalarArith::|, false)

BOOL_REDUCE

/******************************************************************************
 *
 * @fn <a>[n] mask(bool[n] p, <a>[n] A, <a>[n] B)
 *
 * @brief mask has the same semantics as where, but it does not use WLs.
 * These versions are defined on scalars/vectors only, but they could be
 * extended to higher-order arrays via a WL.
 *
 * @remark Unlike where, they compute both legs of the "conditional", which
 * may be a feature or a bug, depending on your point of view.
 *
 ******************************************************************************/

#define MASK_VxVxV(typ, postfix, zval, oval)                                   \
inline                                                                         \
typ[n] mask(bool[n] p, typ[n] A, typ[n] B)                                     \
{                                                                              \
    return _mask_VxVxV_(p, A, B);                                              \
}

#define MASK_VxVxS(typ, postfix, zval, oval)                                   \
inline                                                                         \
typ[n] mask(bool[n] p, typ[n] A, typ B)                                        \
{                                                                              \
    return _mask_VxVxS_(p, A, B);                                              \
}

#define MASK_VxSxV(typ, postfix, zval, oval)                                   \
inline                                                                         \
typ[n] mask(bool[n] p, typ A, typ[n] B)                                        \
{                                                                              \
    return _mask_VxSxV_(p, A, B);                                              \
}

#define MASK_VxSxS(typ, postfix, zval, oval)                                   \
inline                                                                         \
typ[n] mask(bool[n] p, typ A, typ B)                                           \
{                                                                              \
    return _mask_VxSxS_(p, A, B);                                              \
}

#define MASK_SxVxV(typ, postfix, zval, oval)                                   \
inline                                                                         \
typ[n] mask(bool p, typ[n] A, typ[n] B)                                        \
{                                                                              \
    return _mask_SxVxV_(p, A, B);                                              \
}

#define MASK_SxVxS(typ, postfix, zval, oval)                                   \
inline                                                                         \
typ[n] mask(bool p, typ[n] A, typ B)                                           \
{                                                                              \
    return _mask_SxVxS_(p, A, B);                                              \
}

#define MASK_SxSxV(typ, postfix, zval, oval)                                   \
inline                                                                         \
typ[n] mask(bool p, typ A, typ[n] B)                                           \
{                                                                              \
    return _mask_SxSxV_(p, A, B);                                              \
}

#define MASK_SxSxS(typ, postfix, zval, oval)                                   \
inline                                                                         \
typ mask(bool p, typ A, typ B)                                                 \
{                                                                              \
    return _mask_SxSxS_(p, A, B);                                              \
}

#define MASK(typ, postfix, zval, oval)                                         \
MASK_VxVxV(typ, postfix, zval, oval)                                           \
MASK_VxVxS(typ, postfix, zval, oval)                                           \
MASK_VxSxV(typ, postfix, zval, oval)                                           \
MASK_VxSxS(typ, postfix, zval, oval)                                           \
MASK_SxVxV(typ, postfix, zval, oval)                                           \
MASK_SxVxS(typ, postfix, zval, oval)                                           \
MASK_SxSxV(typ, postfix, zval, oval)                                           \
MASK_SxSxS(typ, postfix, zval, oval)

BUILT_IN(MASK)
