module ArrayTransform;

use Constants: all;
use ArrayBasics: all;

export all;

#include "Templates.mac"

/******************************************************************************
 *
 * Structural OPS.
 *
 ******************************************************************************/

 /******************************************************************************
 *
 * @fn <a>[n:v, m:ishp] take( int[n] v, typ[n:ohsp, m:ishp] A)
 *
 * @brief Takes a number of elements from the array, given a shape vector.
 *
 * @remark Take does NOT support overtake
 *         E.g., take( [5], [2, 3]) throws an error.
 *
 * @remark Take supports negative v, taking the last elements
 *         E.g., take( [-1], [2, 3]) =
 *           [3]
 *
 * @remark Take supports lower-dimensional v, padding the missing elements
 *         with corresponding elements from shp.
 *         E.g., take( [1], genarray( [2,2], 42)) =
 *           [[42, 42]]
 *
 ******************************************************************************/

#define TAKE( typ, postfix, zval, oval)                                        \
inline                                                                         \
typ[n:v, m:ishp] take( int[n] v, typ[n:oshp, m:ishp] A)                        \
  | _all_V_( _le_VxV_( _abs_V_(v), oshp))                                      \
{                                                                              \
  /* Start shows the index of the first element to be selected. */             \
  start = where( _lt_VxS_( v, 0),                                              \
                 _add_VxV_( oshp, v),                                          \
                 0);                                                           \
  /* Stop signals the location of the last index element of array. */          \
  stop = _abs_V_( v);                                                          \
  return { iv -> A[ _add_VxV_( start, iv)] | iv < stop };                      \
}

BUILT_IN( TAKE)


/******************************************************************************
 *
 * @fn <a>[n:v, m:ishp] take_apl( int[n] v, typ[n:ohsp, m:ishp] A)
 *
 * @brief Takes a number of elements from the array in APL style
 *        , given a shape vector.
 *
 * @remark take_apl supports overtake
 *         E.g., take( [5], [2, 3]) =
 *           [2, 3, 0, 0, 0]
 *
 * @remark take_apl supports negative v, taking the last elements
 *         E.g., take( [-1], [2, 3]) =
 *           [3]
 *             , take( [-5], [2, 3]) =
 *           [0, 0, 0, 2, 3]
 *
 * @remark take_apl supports lower-dimensional v, padding the missing elements
 *         with corresponding elements from shp.
 *         E.g., take( [3], genarray( [2,2], 42)) =
 *           [[42, 42]
 *            [42, 42]
 *            [0,  0]]
 *
 ******************************************************************************/

#define TAKE_APL( typ, postfix, zval, oval)                                    \
inline                                                                         \
typ[n:v, m:ishp] take_apl( int[n] v, typ[n:oshp, m:ishp] A)                    \
{                                                                              \
  /* Offset shows the index of the first element to be selected. */            \
  offset = where( _lt_VxS_(v, 0),                                              \
              _add_VxV_( oshp, v),                                             \
              0);                                                              \
  /*                                                                           \
   * Stop signals the location of the last index element of array.             \
   * This can be longer than the size of the array, in case offset             \
   * is less than (-oshp).                                                     \
  */                                                                           \
  stop = where( _lt_VxS_( v, 0),                                               \
            _abs_V_(v),                                                        \
            _min_VxV_( _abs_V_(v), oshp));                                     \
  /*                                                                           \
   * Start shows where the selection of array elements starts.                 \
   * This can only be different from offset if offset < (-oshp).               \
  */                                                                           \
  start = _max_VxS_( _neg_V_(offset), 0);                                      \
  /* The result is calculated in 2 steps: */                                   \
  res = { /* 1: select the required elements of the array */                   \
          iv -> A[ _add_VxV_( offset, iv)] | start <= iv < stop;               \
          /* 2: add zeros around (if needed) */                                \
          iv -> genarray( ishp, zval) | iv < _abs_V_(v) };                     \
  return(res);                                                                 \
}

BUILT_IN( TAKE_APL)


/******************************************************************************
 *
 * @fn <a>[n:shp_res, m:ishp] drop( int[n] sv, <a>[n:oshp, m:ishp] A)
 *
 * @brief Drops a number of elements from the array in APL style
 *        , given a shape vector.
 *
 * @remark drop does NOT support overdrop
 *         E.g., drop( [5], [2, 3]) throws an error.
 *
 * @remark drop_apl supports negative v, dropping the last elements
 *         E.g., drop( [-1], [2, 3]) =
 *           [2]
 *
 * @remark drop_apl supports lower-dimensional v, padding the missing elements
 *         with corresponding elements from shp.
 *         E.g., drop( [1], genarray( [2,2], 42)) =
 *           [[42, 42]]
 *
 ******************************************************************************/

#define DROP( typ, postfix, zval, oval)                                        \
inline                                                                         \
typ[n:shp_res, m:ishp] drop( int[n] v, typ[n:oshp, m:ishp] A)                  \
  | _all_V_( _le_VxV_( _abs_V_(v), oshp))                                      \
{                                                                              \
  /* Calculate shape of result array. */                                       \
  shp_res = _sub_VxV_( oshp, _abs_V_(v));                                      \
  /* Start shows the index of the first element to be selected. */             \
  start = _max_VxS_( v, 0);                                                    \
  return { iv -> A[ _add_VxV_( start, iv)] | iv < shp_res };                   \
}

BUILT_IN( DROP)


/******************************************************************************
 *
 * @fn <a>[n:shp_res, m:ishp] drop_apl( int[n] sv, <a>[n:oshp, m:ishp] A)
 *
 * @brief Drops a number of elements from the array in APL style
 *        , given a shape vector.
 *
 * @remark drop_apl supports overdrop
 *         E.g., drop( [5], [2, 3]) =
 *           []
 *
 * @remark drop_apl supports negative v, dropping the last elements
 *         E.g., drop( [-1], [2, 3]) =
 *           [2]
 *
 * @remark drop_apl supports lower-dimensional v, padding the missing elements
 *         with corresponding elements from shp.
 *         E.g., drop( [1], genarray( [2,2], 42)) =
 *           [[42, 42]]
 *
 ******************************************************************************/

#define DROP_APL( typ, postfix, zval, oval)                                    \
inline                                                                         \
typ[n:shp_res, m:ishp] drop_apl( int[n] v, typ[n:oshp, m:ishp] A)              \
{                                                                              \
  /* Calculate shape of result array. */                                       \
  shp_res = _sub_VxV_( oshp, _abs_V_(v));                                      \
  shp_res = _max_VxS_( shp_res, 0);                                            \
  /* Start shows the index of the first element to be selected. */             \
  start = _max_VxS_( v, 0);                                                    \
  /* Select the requested elements of array A. */                              \
  return { iv -> A[ _add_VxV_( start, iv)] | iv < shp_res };                   \
}

BUILT_IN( DROP_APL)


/******************************************************************************
 *
 * @fn <a>[n:shp] tile( int[n] shp, int[n] idx, <a>[n:shp_a] A)
 *
 * @brief Takes a tile from the array, of shape shp, starting at index idx.
 *
 * @remark tile_apl does NOT support overtile
 *         E.g., tile( [5], [1], [2, 3, 4]) throws an error.
 *
 ******************************************************************************/

#define TILE( typ, postfix, zval, oval)                                        \
inline                                                                         \
typ[n:shp] tile( int[n] shp, int[n] idx, typ[n:shp_a] A)                       \
  | _all_V_( _ge_VxS_( shp, 0)),                                               \
    _all_V_( _ge_VxS_( idx, 0)),                                               \
    _all_V_( _le_VxV_( _add_VxV_( shp, idx), shp_a))                           \
{                                                                              \
  return { iv -> A[ _add_VxV_( idx, iv)] | iv < shp };                         \
}

BUILT_IN( TILE)


/******************************************************************************
 *
 * @fn <a>[n:shp] tile_apl( int[n] shp, int[n] idx, <a>[n:shp_a] A)
 *
 * @brief Takes a tile from the array, of shape shp, starting at index idx.
 *
 * @remark tile_apl supports overtile
 *         E.g., tile( [5], [1], [2, 3, 4]) =
 *           [3, 4, 0, 0, 0]
 *
 ******************************************************************************/

#define TILE_APL( typ, postfix, zval, oval)                                    \
inline                                                                         \
typ[n:shp] tile_apl( int[n] shp, int[n] idx, typ[n:shp_a] A)                   \
| _all_V_( _ge_VxS_( shp, 0))                                                  \
{                                                                              \
  /* Start shows how many elements we prepend before the array. */             \
  start = _max_VxS_( _neg_V_(idx), 0);                                         \
  /*                                                                           \
   * Stop shows where our selection of the given array ends, or, in case       \
   * the selection goes beyond the array, where the array ends.                \
  */                                                                           \
  stop = _min_VxV_( shp, _sub_VxV_( shp_a, idx));                              \
  /* The result is calculated in 2 steps: */                                   \
  return { /* 1: select the required elements of the array */                  \
           iv -> A[ _add_VxV_( idx, iv)] | start <= iv < stop;                 \
           /* 2: add zeros around (if needed) */                               \
           iv -> zval | iv < shp};                                             \
}

BUILT_IN( TILE_APL)


/******************************************************************************
 *
 * @fn <a>[o,d:shp] ++( <a>[n,d:shp] A, <a>[m,d:shp] B)
 *
 * @brief First-axis catenation.
 *
 ******************************************************************************/

#define CAT_AxA( typ, postfix, zval, oval)                                     \
inline                                                                         \
typ[o, d:shp] ++( typ[n, d:shp] A, typ[m, d:shp] B)                            \
  | _eq_SxS_( o, _add_SxS_( n, m))                                             \
{                                                                              \
  o = _add_SxS_( n, m);                                                        \
  return { [i] -> A[i] | [i] < [n];                                            \
           [i] -> B[ _sub_SxS_( i, n)] | [n] <= [i] < [o] };                   \
}

#define CAT_AxS( typ, postfix, zval, oval)                                     \
inline                                                                         \
typ[o, d:shp] ++( typ[n, d:shp] A, typ B)                                      \
  | _eq_SxS_( o, _add_SxS_( n, 1))                                             \
{                                                                              \
  o = _add_SxS_( n, 1);                                                        \
  return { [i] -> A[i] | [i] < [n];                                            \
           [i] -> genarray( shp, B) | [n] <= [i] < [o] };                      \
}

#define CAT_SxA( typ, postfix, zval, oval)                                     \
inline                                                                         \
typ[o, d:shp] ++( typ A, typ[m, d:shp] B)                                      \
  | _eq_SxS_( o, _add_SxS_( 1, m))                                             \
{                                                                              \
  o = _add_SxS_( 1, m);                                                        \
  return { [i] -> genarray( shp, A) | [i] < [1];                               \
           [i] -> B[ _sub_SxS_( i, 1)] | [1] <= [i] < [o] };                   \
}

#define CAT_SxS( typ, postfix, zval, oval)                                     \
inline                                                                         \
typ[2] ++( typ A, typ B)                                                       \
{                                                                              \
  return [ A, B];                                                              \
}

#define CAT( typ, postfix, zval, oval)                                         \
CAT_AxA( typ, postfix, zval, oval)                                             \
CAT_AxS( typ, postfix, zval, oval)                                             \
CAT_SxA( typ, postfix, zval, oval)                                             \
CAT_SxS( typ, postfix, zval, oval)

BUILT_IN( CAT)


/******************************************************************************
 *
 * @fn <a>[d:shp,o] ++( <a>[d:shp,n] A, <a>[d:shp,m] B)
 *
 * @brief Last-axis catenation. We assume that A and B are the same shape,
 * except perhaps along the last axis.
 *
 ******************************************************************************/

#define CATENATE_AxA( typ, postfix, zval, oval)                                \
inline                                                                         \
typ[d:shp,o] catenate( typ[d:shp,n] A, typ[d:shp,m] B)                         \
  | _eq_SxS_( o, _add_SxS_( n, m))                                             \
{                                                                              \
  return { iv -> _cat_VxV_( A[iv], B[iv]) | iv < shp };                        \
}

#define CATENATE_AxS( typ, postfix, zval, oval)                                \
inline                                                                         \
typ[d:shp,o] catenate( typ[d:shp,n] A, typ B)                                  \
  | _eq_SxS_( o, _add_SxS_( n, 1))                                             \
{                                                                              \
  return { iv -> _cat_VxV_( A[iv], [B]) | iv < shp };                          \
}

#define CATENATE_SxA( typ, postfix, zval, oval)                                \
inline                                                                         \
typ[d:shp,o] catenate( typ A, typ[d:shp,m] B)                                  \
  | _eq_SxS_( o, _add_SxS_( 1, m))                                             \
{                                                                              \
  return { iv -> _cat_VxV_( [A], B[iv]) | iv < shp };                          \
}

#define CATENATE_SxS( typ, postfix, zval, oval)                                \
inline                                                                         \
typ[2] catenate( typ A, typ B)                                                 \
{                                                                              \
  return [ A, B];                                                              \
}

#define CATENATE( typ, postfix, zval, oval)                                    \
CATENATE_AxA( typ, postfix, zval, oval)                                        \
CATENATE_AxS( typ, postfix, zval, oval)                                        \
CATENATE_SxA( typ, postfix, zval, oval)                                        \
CATENATE_SxS( typ, postfix, zval, oval)

BUILT_IN( CATENATE)


/******************************************************************************
 *
 * @fn <a>[n,d:shp] reverse( <a>[n,d:shp] A)
 *
 * @brief First-axis reverse.
 *
 ******************************************************************************/

#define REVERSE( typ, postfix, zval, oval)                                     \
inline                                                                         \
typ[n,d:shp] reverse( typ[n,d:shp] A)                                          \
{                                                                              \
  max = _sub_SxS_( n, 1);                                                      \
  return { [i] -> A[ _sub_SxS_( max, i)] | [i] <= [max] };                     \
}

BUILT_IN( REVERSE)


/******************************************************************************
 *
 * @fn <a>[d:shp] reverse( int axis, <a>[d:shp] A)
 *
 * @brief Reverse on specified axis: 0 is leading axis, dim-1 is trailing axis.
 *
 ******************************************************************************/

#define REVERSEAXIS( typ, postfix, zval, oval)                                 \
inline                                                                         \
typ[axis:oshp, n, d:shp] reverse( int axis, typ[axis:oshp, n, d:shp] A)        \
{                                                                              \
  return { iv -> reverse( A[iv]) | iv < oshp };                                \
}

BUILT_IN( REVERSEAXIS)


/******************************************************************************
 *
 * @fn <a>[d:shpT] transpose( <a>[d:shp] A)
 *
 * @brief transposes the given array.
 *
 ******************************************************************************/

#define TRANSPOSE( typ, postfix, zval, oval)                                   \
inline                                                                         \
typ[d:shp_t] transpose( typ[d:shp] A)                                          \
  | _all_V_( _eq_VxV_( reverse(shp), shp_t))                                   \
{                                                                              \
  shp_t = reverse( shp);                                                       \
  return { iv -> A[ reverse(iv)] | iv < shp_t };                               \
}

BUILT_IN( TRANSPOSE)


/******************************************************************************
 *
 * @fn <a>[d:shp] shift (int dim, int count, typ boundary, <a>[d:shp] A)
 *
 * @brief shifts the given array. Positive shift is to right, negative to left.
 *
 ******************************************************************************/

#define SHIFT_S( typ, postfix, zval, oval)                                     \
inline                                                                         \
typ[d1:oshp, n, d2:ishp] shift                                                 \
( int d1, int count, typ boundary, typ[d1:oshp, n, d2:ishp] A)                 \
{                                                                              \
  return                                                                       \
    { iv ->                                                                    \
      { [i] -> ( _lt_SxS_( _sub_SxS_( i, count), n )                           \
              && _ge_SxS_( _sub_SxS_( i, count), 0) )                          \
      ? A[ _cat_VxV_( iv, [ _sub_SxS_( i, count)] ) ]                          \
      : genarray( ishp, boundary) | [i] < [n] }                                \
    | iv < oshp };                                                             \
}


#define SHIFT_V( typ, postfix, zval, oval)                                     \
inline                                                                         \
typ[n:oshp, m:ishp] shift( int[n] counts, typ boundary, typ[n:oshp, m:ishp] A) \
{                                                                              \
  counts_ext = _cat_VxV_( counts, genarray( [m], 0));                          \
  shp = _cat_VxV_( oshp, ishp);                                                \
  idx = _neg_V_(counts_ext);                                                   \
  return tile_apl( shp, idx, A);                                               \
}

#define SHIFT_VZ( typ, postfix, zval, oval)                                    \
inline                                                                         \
typ[n:oshp, m:ishp] shift( int[n] counts, typ[n:oshp, m:ishp] A)               \
{                                                                              \
  return shift( counts, zval, A);                                              \
}

#define SHIFT( typ, postfix, zval, oval)                                       \
SHIFT_S( typ, postfix, zval, oval)                                             \
SHIFT_V( typ, postfix, zval, oval)                                             \
SHIFT_VZ( typ, postfix, zval, oval)

BUILT_IN( SHIFT)


/******************************************************************************
 *
 * @fn <a>[d:shp] rotate( int dim, int count, <a>[d:shp] A)
 *
 * @brief Rotates the given array, wrapping values that go out of bounds.
 * Positive rotate is to right, negative to left.
 *
 * @example rotate( [2], iota( 5)) = [3, 4, 0, 1, 2]
 *
 *
 ******************************************************************************/

#define ROTATE_S( typ, postfix, zval, oval)                                    \
inline                                                                         \
typ[dim:oshp, n, d:ishp] rotate                                                \
( int dim, int count, typ[dim:oshp, n, d:ishp] A)                              \
{                                                                              \
  return                                                                       \
    { iv ->                                                                    \
      { [i] ->                                                                 \
        A[ _cat_VxV_( iv, [ _aplmod_SxS_( _sub_SxS_( i, count), n)])]          \
      | [i] < [n] }                                                            \
    | iv < oshp };                                                             \
}

#define ROTATE_V( typ, postfix, zval, oval)                                    \
inline                                                                         \
typ[n:oshp, m:ishp] rotate( int[n] counts, typ[n:oshp, m:ishp] A)              \
{                                                                              \
  return { iv ->                                                               \
      A[ { [i] -> _aplmod_SxS_( _sub_SxS_( iv[i], counts[i]), oshp[i])         \
         | [i] < [n] } ]                                                       \
    | iv < oshp };                                                             \
}

#define ROTATE( typ, postfix, zval, oval)                                      \
ROTATE_S( typ, postfix, zval, oval)                                            \
ROTATE_V( typ, postfix, zval, oval)

BUILT_IN( ROTATE)


/******************************************************************************
 *
 * @fn <a>[d:shp] where( bool[d:shp] p, <a>[d:shp] A, <a>[d:shp] B)
 *
 * @brief Selects the element from A if the corresponding value of p is true,
 * otherwise selects the element from B.
 *
 ******************************************************************************/

#define WHERE_AxA( typ, postfix, zval, oval)                                   \
inline                                                                         \
typ[d:shp] where( bool[d:shp] p, typ[d:shp] A, typ[d:shp] B)                   \
{                                                                              \
  return { iv -> p[iv] ? A[iv] : B[iv] };                                      \
}

#define WHERE_AxS( typ, postfix, zval, oval)                                   \
inline                                                                         \
typ[d:shp] where( bool[d:shp] p, typ[d:shp] A, typ B)                          \
{                                                                              \
  return { iv -> p[iv] ? A[iv] : B };                                          \
}

#define WHERE_SxA( typ, postfix, zval, oval)                                   \
inline                                                                         \
typ[d:shp] where( bool[d:shp] p, typ A, typ[d:shp] B)                          \
{                                                                              \
  return { iv -> p[iv] ? A : B[iv] };                                          \
}

#define WHERE_SxS( typ, postfix, zval, oval)                                   \
inline                                                                         \
typ[b:shp] where( bool[b:shp] p, typ A, typ B)                                 \
{                                                                              \
  return { iv -> p[iv] ? A : B };                                              \
}

#define WHERE( typ, postfix, zval, oval)                                       \
WHERE_AxA( typ, postfix, zval, oval)                                           \
WHERE_AxS( typ, postfix, zval, oval)                                           \
WHERE_SxA( typ, postfix, zval, oval)                                           \
WHERE_SxS( typ, postfix, zval, oval)

BUILT_IN( WHERE)


/******************************************************************************
 *
 * @fn <a> reduce( <a>[d:shp] A)
 *
 * @brief Reduces the given array to a single element.
 *
 ******************************************************************************/

#define REDUCE( name, typ, fun, neutral)                                       \
inline                                                                         \
typ name( typ[d:shp] A)                                                        \
{                                                                              \
  res = with {                                                                 \
          ( _mul_SxV_( 0, shp) <= iv < shp) : A[iv];                           \
        } : fold( fun, neutral);                                               \
  return res;                                                                  \
}

#define NUM_REDUCE( typ, postfix, zval, oval)                                  \
REDUCE( sum, typ, ScalarArith::+, zval)                                        \
REDUCE( prod, typ, ScalarArith::*, oval)                                       \
REDUCE( maxval, typ, ScalarArith::max, min##typ())                             \
REDUCE( minval, typ, ScalarArith::min, max##typ())

NUM( NUM_REDUCE)

#define BOOL_REDUCE                                                            \
REDUCE( all, bool, ScalarArith::&, true)                                       \
REDUCE( any, bool, ScalarArith::|, false)

BOOL_REDUCE


/******************************************************************************
 *
 * @fn bool match( <a>[n:shpA] A, <a>[m:shpB] B)
 *
 * @brief whether the given arrays are equal.
 *
 ******************************************************************************/

#define MATCH_AxA( typ, postfix, zval, oval)                                   \
inline                                                                         \
bool match( typ[n:shpA] A, typ[m:shpB] B)                                      \
{                                                                              \
  res = _eq_SxS_( n, m)                                                        \
     && _all_V_( _eq_VxV_( shpA, shpB))                                        \
     && with {                                                                 \
          ( _mul_SxV_( 0, shpA) <= iv < shpA)                                  \
            : _eq_SxS_( _sel_VxA_( iv, A), _sel_VxA_( iv, B));                 \
        } : foldfix( ScalarArith::&, true, false);                             \
  return res;                                                                  \
}

#define MATCH_AxS( typ, postfix, zval, oval)                                   \
inline                                                                         \
bool match( typ[+] A, typ B)                                                   \
{                                                                              \
  return false;                                                                \
}

#define MATCH_SxA( typ, postfix, zval, oval)                                   \
inline                                                                         \
bool match( typ A, typ[+] B)                                                   \
{                                                                              \
  return false;                                                                \
}

#define MATCH_SxS( typ, postfix, zval, oval)                                   \
inline                                                                         \
bool match( typ A, typ B)                                                      \
{                                                                              \
  return _eq_SxS_( A, B);                                                      \
}

#define MATCH( typ, postfix, zval, oval)                                       \
MATCH_AxA( typ, postfix, zval, oval)                                           \
MATCH_AxS( typ, postfix, zval, oval)                                           \
MATCH_SxA( typ, postfix, zval, oval)                                           \
MATCH_SxS( typ, postfix, zval, oval)

BUILT_IN( MATCH)


/******************************************************************************
 *
 * @fn <a>[n] mask( bool[n] p, <a>[n] A, <a>[n] B)
 *
 * @brief mask has the same semantics as where, but it does not use WLs.
 * These versions are defined on scalars/vectors only, but they could be
 * extended to higher-order arrays via a WL.
 *
 * @remark Unlike where, they compute both legs of the "conditional", which
 * may be a feature or a bug, depending on your point of view.
 *
 ******************************************************************************/

#define MASK_VxVxV( typ, postfix, zval, oval)                                  \
inline                                                                         \
typ[n] mask( bool[n] p, typ[n] A, typ[n] B)                                    \
{                                                                              \
  return _mask_VxVxV_( p, A, B);                                               \
}

#define MASK_VxVxS( typ, postfix, zval, oval)                                  \
inline                                                                         \
typ[n] mask( bool[n] p, typ[n] A, typ B)                                       \
{                                                                              \
  return _mask_VxVxS_( p, A, B);                                               \
}

#define MASK_VxSxV( typ, postfix, zval, oval)                                  \
inline                                                                         \
typ[n] mask( bool[n] p, typ A, typ[n] B)                                       \
{                                                                              \
  return _mask_VxSxV_( p, A, B);                                               \
}

#define MASK_VxSxS( typ, postfix, zval, oval)                                  \
inline                                                                         \
typ[n] mask( bool[n] p, typ A, typ B)                                          \
{                                                                              \
  return _mask_VxSxS_( p, A, B);                                               \
}

#define MASK_SxVxV( typ, postfix, zval, oval)                                  \
inline                                                                         \
typ[n] mask( bool p, typ[n] A, typ[n] B)                                       \
{                                                                              \
  return _mask_SxVxV_( p, A, B);                                               \
}

#define MASK_SxVxS( typ, postfix, zval, oval)                                  \
inline                                                                         \
typ[n] mask( bool p, typ[n] A, typ B)                                          \
{                                                                              \
  return _mask_SxVxS_( p, A, B);                                               \
}

#define MASK_SxSxV( typ, postfix, zval, oval)                                  \
inline                                                                         \
typ[n] mask( bool p, typ A, typ[n] B)                                          \
{                                                                              \
  return _mask_SxSxV_( p, A, B);                                               \
}

#define MASK_SxSxS( typ, postfix, zval, oval)                                  \
inline                                                                         \
typ mask( bool p, typ A, typ B)                                                \
{                                                                              \
  return _mask_SxSxS_( p, A, B);                                               \
}

#define MASK( typ, postfix, zval, oval)                                        \
MASK_VxVxV( typ, postfix, zval, oval)                                          \
MASK_VxVxS( typ, postfix, zval, oval)                                          \
MASK_VxSxV( typ, postfix, zval, oval)                                          \
MASK_SxVxV( typ, postfix, zval, oval)                                          \
MASK_SxVxS( typ, postfix, zval, oval)                                          \
MASK_SxSxV( typ, postfix, zval, oval)                                          \
MASK_SxSxS( typ, postfix, zval, oval)

// FIXME: Fix _mask_VxSxS_ in ct_prf.c
// MASK_VxSxS( typ, postfix, zval, oval)

BUILT_IN( MASK)
