module ArrayTransform;

use Constants: all;

export all;

#include "Templates.mac"

/******************************************************************************
 *
 * Structural OPS.
 *
 ******************************************************************************/

/******************************************************************************
 *
 * @fn <a>[d:oshp] take( int[vlen] sv, typ[d:shp] A)
 *
 * @brief Takes a number of elements from the array, given a shape vector.
 *
 * @remark Take supports overtake
 *         E.g., take( [5], [2, 3]) =
 *           [2, 3, 0, 0, 0]
 *
 * @remark Take supports short v, padding the missing elements
 *         with corresponding elements from shp.
 *         E.g., take( [3], genarray( [2,2], 42)) =
 *           [[42, 42]
 *            [42, 42]
 *            [0,  0]]
 *
 ******************************************************************************/

#define TAKE( typ, postfix, zval, oval)                                        \
inline                                                                         \
typ[n:v, m:ishp] take( int[n] v, typ[n:oshp, m:ishp] A)                        \
{                                                                              \                                                                             
  // Offset shows the index of the first element to be selected.               \
  offset = ArrayTransform::where( _lt_VxS_(v, 0),                              \
            _add_VxV_( oshp, v),                                               \
            0);                                                                \
  /*                                                                           \
   * Stop signals the location of the last index element of array.             \
   * This can be longer than the size of the array, in case offset             \
   * is less than (-oshp).                                                     \
  */                                                                           \
  stop = ArrayTransform::where( _lt_VxS_(v, 0),                                \
           _abs_V_(v),                                                         \
           _min_VxV_( _abs_V_(v), oshp));                                      \
  /*                                                                           \
   * Start shows where the selection of array elements starts.                 \
   * This can only be different from offset if offset < (-oshp).               \
  */                                                                           \
  start = ArrayTransform::where( _lt_VxS_(_neg_V_(offset), 0),                 \
             0,                                                                \
             _neg_V_(offset));                                                 \
  // The result is calculated in 2 steps:                                      \
  res = {// 1: select the required elements of the array                       \
         iv -> array[ _add_VxV_( offset, iv)] | start <= iv < stop;            \         
         // 2: add zeros around (if needed)                                    \
         iv -> genarray(ishp, zval) | iv < _abs_V_(v)};                        \
  return(res);                                                                 \
}                                                                              \

BUILT_IN( TAKE)


/******************************************************************************
 *
 * @fn <a>[d:oshp] drop( int[vlen] sv, <a>[d:shp] A)
 *
 * @brief Drops a number of elements from the array, given a shape vector.
 *
 ******************************************************************************/

#define DROP( typ, postfix, zval, oval)                                        \
inline                                                                         \
typ[d:oshp] drop( int[vlen] sv, typ[d:shp] A)                                  \
{                                                                              \
  zr = _mul_SxV_( 0, shp);                                                     \
  offset = zr;                                                                 \
  vext = zr;                                                                   \
                                                                               \
  /* Pad drop count */                                                         \
  for (i = 0; _lt_SxS_( i, vlen); i = _add_SxS_( i, 1)) {                      \
    el = _sel_VxA_( [i], sv);                                                  \
    shpel = _sel_VxA_( [i], shp);                                              \
    vext = _idx_modarray_AxSxS_( vext,  i,  el);                               \
    val = _mask_SxSxS_( _le_SxS_( el, 0), 0, _min_SxS_( shpel, el));           \
    offset = _idx_modarray_AxSxS_( offset, i, val);                            \
  }                                                                            \
                                                                               \
  oshp = _max_VxV_( zr, _sub_VxV_( shp, _abs_V_( vext)));                      \
  res = { iv -> _sel_VxA_( _add_VxV_( offset, iv), A) | iv < oshp };           \
  return res;                                                                  \
}

BUILT_IN( DROP)


/******************************************************************************
 *
 * @fn <a>[d:shp] tile( int[d] shp, int[.] idx, <a>[*] A)
 *
 * @brief Takes a tile from the array, of shape shp from at index idx.
 *
 ******************************************************************************/

#define TILE( typ, postfix, zval, oval)                                        \
inline                                                                         \
typ[d:shp] tile( int[d] shp, int[.] idx, typ[*] A)                             \
{                                                                              \
  return { iv -> _sel_VxA_( _add_VxV_( idx, iv), A) | iv < shp };              \
}

BUILT_IN( TILE)


/******************************************************************************
 *
 * @fn <a>[o,d:shp] ++( <a>[n,d:shp] A, <a>[m,d:shp] B)
 *
 * @brief First-axis catenation.
 *
 ******************************************************************************/

#define CAT_AxA( typ, postfix, zval, oval)                                     \
inline                                                                         \
typ[o,d:shp] ++( typ[n,d:shp] A, typ[m,d:shp] B)                               \
{                                                                              \
  o = _add_SxS_( n, m);                                                        \
  oshp = _cat_VxV_( [o], shp);                                                 \
  zshp = _mul_SxV_( 0, oshp);                                                  \
  offset = _cat_VxV_( [n], _mul_SxV_( 0, shp));                                \
  res = with {                                                                 \
          (zshp <= iv < _shape_A_( A)) : _sel_VxA_( iv, A);                    \
          (offset <= iv < oshp)        : _sel_VxA_( _sub_VxV_( iv, offset), B);\
        } : genarray( oshp, zval);                                             \
  return res;                                                                  \
}

#define CAT_AxS( typ, postfix, zval, oval)                                     \
inline                                                                         \
typ[o,d:shp] ++( typ[n,d:shp] A, typ B)                                        \
{                                                                              \
  o = _add_SxS_( n, 1);                                                        \
  oshp = _cat_VxV_( [o], shp);                                                 \
  zshp = _mul_SxV_( 0, oshp);                                                  \
  offset = _cat_VxV_( [n], _mul_SxV_( 0, shp));                                \
  res = with {                                                                 \
          (zshp <= iv < _shape_A_( A)) : _sel_VxA_( iv, A);                    \
          (offset <= iv < oshp)        : B;                                    \
        } : genarray( oshp, zval);                                             \
  return res;                                                                  \
}

#define CAT_SxA( typ, postfix, zval, oval)                                     \
inline                                                                         \
typ[o,d:shp] ++( typ A, typ[m,d:shp] B)                                        \
{                                                                              \
  o = _add_SxS_( m, 1);                                                        \
  oshp = _cat_VxV_( [o], shp);                                                 \
  zshp = _mul_SxV_( 0, oshp);                                                  \
  offset = _cat_VxV_( [m], _mul_SxV_( 0, shp));                                \
  res = with {                                                                 \
          (zshp <= iv < _shape_A_( B)) : _sel_VxA_( iv, B);                    \
          (offset <= iv < oshp)        : A;                                    \
        } : genarray( oshp, zval);                                             \
  return res;                                                                  \
}

#define CAT_SxS( typ, postfix, zval, oval)                                     \
inline                                                                         \
typ[2] ++( typ A, typ B)                                                       \
{                                                                              \
  return [A, B];                                                               \
}

#define CAT( typ, postfix, zval, oval)                                         \
CAT_AxA( typ, postfix, zval, oval)                                             \
CAT_AxS( typ, postfix, zval, oval)                                             \
CAT_SxA( typ, postfix, zval, oval)                                             \
CAT_SxS( typ, postfix, zval, oval)

BUILT_IN( CAT)


/******************************************************************************
 *
 * @fn <a>[d:shp,o] ++( <a>[d:shp,n] A, <a>[d:shp,m] B)
 *
 * @brief Last-axis catenation. We assume that A and B are the same shape,
 * except perhaps along the last axis.
 *
 ******************************************************************************/

#define CATENATE_AxA( typ, postfix, zval, oval)                                \
inline                                                                         \
typ[d:shp,o] catenate( typ[d:shp,n] A, typ[d:shp,m] B)                         \
{                                                                              \
  o = _add_SxS_( n, m);                                                        \
  oshp = _cat_VxV_( shp, [o]);                                                 \
  zshp = _mul_SxV_( 0, oshp);                                                  \
  offset = _cat_VxV_( _mul_SxV_( 0, shp), [n]);                                \
  res = with {                                                                 \
          (zshp <= iv < offset) : _sel_VxA_( iv, A);                           \
          (offset <= iv < oshp) : _sel_VxA_( _sub_VxV_( iv, offset), B);       \
        } : genarray( oshp, zval);                                             \
  return res;                                                                  \
}

#define CATENATE_AxS( typ, postfix, zval, oval)                                \
inline                                                                         \
typ[d:shp,o] catenate( typ[d:shp,n] A, typ B)                                  \
{                                                                              \
  o = _add_SxS_( n, 1);                                                        \
  oshp = _cat_VxV_( shp, [o]);                                                 \
  zshp = _mul_SxV_( 0, oshp);                                                  \
  offset = _cat_VxV_( _mul_SxV_( 0, shp), [n]);                                \
  res = with {                                                                 \
          (zshp <= iv < offset) : _sel_VxA_( iv, A);                           \
          (offset <= iv < oshp) : B;                                           \
        } : genarray( oshp, zval);                                             \
  return res;                                                                  \
}

#define CATENATE_SxA( typ, postfix, zval, oval)                                \
inline                                                                         \
typ[d:shp,o] catenate( typ A, typ[d:shp,m] B)                                  \
{                                                                              \
  o = _add_SxS_( m, 1);                                                        \
  oshp = _cat_VxV_( shp, [o]);                                                 \
  zshp = _mul_SxV_( 0, oshp);                                                  \
  offset = _cat_VxV_( _mul_SxV_( 0, shp), [m]);                                \
  res = with {                                                                 \
          (zshp <= iv < offset) : A;                                           \
          (offset <= iv < oshp) : _sel_VxA_( _sub_VxV_( iv, offset), B);       \
        } : genarray( oshp, zval);                                             \
  return res;                                                                  \
}

#define CATENATE_SxS( typ, postfix, zval, oval)                                \
inline                                                                         \
typ[2] catenate( typ A, typ B)                                                 \
{                                                                              \
  return [A, B];                                                               \
}

#define CATENATE( typ, postfix, zval, oval)                                    \
CATENATE_AxA( typ, postfix, zval, oval)                                        \
CATENATE_AxS( typ, postfix, zval, oval)                                        \
CATENATE_SxA( typ, postfix, zval, oval)                                        \
CATENATE_SxS( typ, postfix, zval, oval)

BUILT_IN( CATENATE)


/******************************************************************************
 *
 * @fn <a>[n,d:shp] reverse( <a>[n,d:shp] A)
 *
 * @brief First-axis reverse.
 *
 ******************************************************************************/

#define REVERSE( typ, postfix, zval, oval)                                     \
inline                                                                         \
typ[n,d:shp] reverse( typ[n,d:shp] A)                                          \
{                                                                              \
  max = _sub_SxS_( n, 1);                                                      \
  res = with {                                                                 \
          ([0] <= [i] <= [max]) : _sel_VxA_( [_sub_SxS_( max, i)], A);         \
        } : modarray( A);                                                      \
  return res;                                                                  \
}

BUILT_IN( REVERSE)


/******************************************************************************
 *
 * @fn <a>[d:shp] reverse( int axis, <a>[d:shp] A)
 *
 * @brief Reverse on specified axis: 0 is leading axis, dim-1 is trailing axis.
 *
 ******************************************************************************/

#define REVERSEAXIS( typ, postfix, zval, oval)                                 \
inline                                                                         \
typ[d:shp] reverse( int axis, typ[d:shp] A)                                    \
{                                                                              \
  shpel = _sel_VxA_( [axis], shp);                                             \
  offset = _sub_SxS_( shpel, 1);                                               \
  res = with {                                                                 \
          ( . <= iv <= . ) {                                                   \
            i = _sel_VxA_( [axis], iv);                                        \
            idx = _modarray_AxVxS_( iv, [axis], _sub_SxS_( offset, i));        \
          } : _sel_VxA_( idx, A);                                              \
        } : modarray( A);                                                      \
  return res;                                                                  \
}

BUILT_IN( REVERSEAXIS)


/******************************************************************************
 *
 * @fn <a>[d:shpT] transpose( <a>[d:shp] A)
 *
 * @brief transposes the given array.
 *
 ******************************************************************************/

#define TRANSPOSE( typ, postfix, zval, oval)                                   \
inline                                                                         \
typ[d:shpT] transpose( typ[d:shp] A)                                           \
{                                                                              \
  return { iv -> _sel_VxA_( reverse( iv), A) | iv < shp };                     \
}

BUILT_IN( TRANSPOSE)


/******************************************************************************
 *
 * @fn <a>[d:shp] shift (int dim, int count, typ boundary, <a>[d:shp] A)
 *
 * @brief shifts the given array. Positive shift is to right, negative to left.
 *
 ******************************************************************************/

#define SHIFT_S( typ, postfix, zval, oval)                                     \
inline                                                                         \
typ[d:shp] shift( int dim, int count, typ boundary, typ[d:shp] A)              \
  | _le_SxS_( 0, dim), _lt_SxS_( dim, d)                                       \
{                                                                              \
  /* Prevent overshift */                                                      \
  abscount = _abs_S_( count);                                                  \
  max_shift = _sel_VxA_( [dim], shp);                                          \
  count = _min_SxS_( abscount, max_shift);                                     \
  cneg = _toi_S_( _lt_SxS_( count, 0));                                        \
  cnonneg = _toi_S_( _ge_SxS_( count, 0));                                     \
                                                                               \
  zr = _mul_SxV_( 0, shp);                                                     \
  lb = _modarray_AxVxS_( zr, [dim], _mul_SxS_( count, cnonneg));               \
  offset = _modarray_AxVxS_( zr, [dim], _neg_S_( count));                      \
  ubel = _sub_SxS_( max_shift, _mul_SxS_( abscount, cneg));                    \
  ub = _modarray_AxVxS_( shp, [dim], ubel);                                    \
                                                                               \
  res = with {                                                                 \
          (lb <= iv < ub)                                                      \
            : _sel_VxA_( _add_VxV_( iv, offset), A);                           \
        } : genarray( shp, boundary);                                          \
  return res;                                                                  \
}

#define SHIFT_V( typ, postfix, zval, oval)                                     \
inline                                                                         \
typ[d:shp] shift( int[n] counts, typ boundary, typ[d:shp] A)                   \
  | _le_SxS_( n, d)                                                            \
{                                                                              \
  for (i = 0; _lt_SxS_( i, n); i = _add_SxS_( i, 1)) {                         \
    offset = _sel_VxA_( [i], counts);                                          \
    A = shift( i, offset, boundary, A);                                        \
  }                                                                            \
  return A;                                                                    \
}

#define SHIFT_VZ( typ, postfix, zval, oval)                                    \
inline                                                                         \
typ[d:shp] shift( int[n] counts, typ[d:shp] A)                                 \
  | n <= d                                                                     \
{                                                                              \
  return shift( counts, zval, A);                                              \
}

#define SHIFT( typ, postfix, zval, oval)                                       \
SHIFT_S( typ, postfix, zval, oval)                                             \
SHIFT_V( typ, postfix, zval, oval)                                             \
SHIFT_VZ( typ, postfix, zval, oval)

BUILT_IN( SHIFT)


/******************************************************************************
 *
 * @fn <a>[d:shp] rotate( int dim, int count, <a>[d:shp] A)
 *
 * @brief Rotates the given array, wrapping values that go out of bounds.
 * Positive rotate is to right, negative to left.
 *
 * @example rotate( [2], iota( 5)) = [3, 4, 0, 1, 2]
 *
 * @remark The definition of ROTATE_V is poor: it will never WLF/AWLF on arrays
 * of rank > 2, because maxlur = 2, by default. Better just to use compositions
 * of rotates, I think, but if you're keen, then use -maxlur 42 or something
 * like that.
 *
 ******************************************************************************/

#define ROTATE_S( typ, postfix, zval, oval)                                    \
inline                                                                         \
typ[d:shp] rotate( int dim, int count, typ[d:shp] A)                           \
  | _le_SxS_( 0, dim), _lt_SxS_( dim, d)                                       \
{                                                                              \
  max_rotate = _sel_VxA_( [dim], shp);                                         \
  count = _aplmod_SxS_( count, max_rotate);                                    \
  offset = _modarray_AxVxS_( _mul_SxV_( 0, shp), [dim], count);                \
  res = with {                                                                 \
          (offset <= iv <= . )                                                 \
            : _sel_VxA_( _sub_VxV_( iv, offset), A);                           \
        } : modarray( A);                                                      \
  slice_shp = _modarray_AxVxS_( shp, [dim], count);                            \
  res = with {                                                                 \
          ( . <= iv < slice_shp)                                               \
            : _sel_VxA_( _add_VxV_( iv, _sub_VxV_( shp, slice_shp)), A);       \
        } : modarray( res);                                                    \
  return res;                                                                  \
}

#define ROTATE_V( typ, postfix, zval, oval)                                    \
inline                                                                         \
typ[d:shp] rotate (int[n] counts,  typ[d:shp] A)                               \
  | _le_SxS_( n, d)                                                            \
{                                                                              \
  for (i = 0; _lt_SxS_( i, n); i = _add_SxS_( i, 1)) {                         \
    offset = _sel_VxA_( [i], counts);                                          \
    A = rotate( i, offset, A);                                                 \
  }                                                                            \
  return A;                                                                    \
}

#define ROTATE( typ, postfix, zval, oval)                                      \
ROTATE_S( typ, postfix, zval, oval)                                            \
ROTATE_V( typ, postfix, zval, oval)

BUILT_IN( ROTATE)


/******************************************************************************
 *
 * @fn <a>[d:shp] where( bool[d:shp] p, <a>[d:shp] A, <a>[d:shp] B)
 *
 * @brief Selects the element from A if the corresponding value of p is true,
 * otherwise selects the element from B.
 *
 ******************************************************************************/

#define WHERE_AxA( typ, postfix, zval, oval)                                   \
inline                                                                         \
typ[d:shp] where( bool[d:shp] p, typ[d:shp] A, typ[d:shp] B)                   \
{                                                                              \
  return { iv -> _sel_VxA_( iv, p) ? _sel_VxA_( iv, A) : _sel_VxA_( iv, B) };  \
}

#define WHERE_AxS( typ, postfix, zval, oval)                                   \
inline                                                                         \
typ[d:shp] where( bool[d:shp] p, typ[d:shp] A, typ B)                          \
{                                                                              \
  return { iv -> _sel_VxA_( iv, p) ? _sel_VxA_( iv, A) : B };                  \
}

#define WHERE_SxA( typ, postfix, zval, oval)                                   \
inline                                                                         \
typ[d:shp] where( bool[d:shp] p, typ A, typ[d:shp] B)                          \
{                                                                              \
  return { iv -> _sel_VxA_( iv, p) ? A : _sel_VxA_( iv, B) };                  \
}

#define WHERE_SxS( typ, postfix, zval, oval)                                   \
inline                                                                         \
typ[b:shp] where( bool[b:shp] p, typ A, typ B)                                 \
{                                                                              \
  return { iv -> _sel_VxA_( iv, p) ? A : B };                                  \
}

#define WHERE( typ, postfix, zval, oval)                                       \
WHERE_AxA( typ, postfix, zval, oval)                                           \
WHERE_AxS( typ, postfix, zval, oval)                                           \
WHERE_SxA( typ, postfix, zval, oval)                                           \
WHERE_SxS( typ, postfix, zval, oval)

BUILT_IN( WHERE)


/******************************************************************************
 *
 * @fn <a> reduce( <a>[d:shp] A)
 *
 * @brief Reduces the given array to a single element.
 *
 ******************************************************************************/

#define REDUCE( name, typ, fun, neutral)                                       \
inline                                                                         \
typ name( typ[d:shp] A)                                                        \
{                                                                              \
  res = with {                                                                 \
          (_mul_SxV_( 0, shp) <= iv < shp) : _sel_VxA_( iv, A);                \
        } : fold( fun, neutral);                                               \
  return res;                                                                  \
}

#define NUM_REDUCE( typ, postfix, zval, oval)                                  \
REDUCE( sum, typ, ScalarArith::+, zval)                                        \
REDUCE( prod, typ, ScalarArith::*, oval)                                       \
REDUCE( maxval, typ, ScalarArith::max, min##typ())                             \
REDUCE( minval, typ, ScalarArith::min, max##typ())

NUM( NUM_REDUCE)

#define BOOL_REDUCE                                                            \
REDUCE( all, bool, ScalarArith::&, true)                                       \
REDUCE( any, bool, ScalarArith::|, false)

BOOL_REDUCE


/******************************************************************************
 *
 * @fn bool match( <a>[n:shpA] A, <a>[m:shpB] B)
 *
 * @brief whether the given arrays are equal.
 *
 ******************************************************************************/

#define MATCH_AxA( typ, postfix, zval, oval)                                   \
inline                                                                         \
bool match( typ[n:shpA] A, typ[m:shpB] B)                                      \
{                                                                              \
  res = _eq_SxS_( n, m)                                                        \
     && _all_V_( _eq_VxV_( shpA, shpB))                                        \
     && with {                                                                 \
          (_mul_SxV_( 0, shpA) <= iv < shpA)                                   \
            : _eq_SxS_( _sel_VxA_( iv, A), _sel_VxA_( iv, B));                 \
        } : foldfix( ScalarArith::&, true, false);                             \
  return res;                                                                  \
}

#define MATCH_AxS( typ, postfix, zval, oval)                                   \
inline                                                                         \
bool match( typ[+] A, typ B)                                                   \
{                                                                              \
  return false;                                                                \
}

#define MATCH_SxA( typ, postfix, zval, oval)                                   \
inline                                                                         \
bool match( typ A, typ[+] B)                                                   \
{                                                                              \
  return false;                                                                \
}

#define MATCH_SxS( typ, postfix, zval, oval)                                   \
inline                                                                         \
bool match( typ A, typ B)                                                      \
{                                                                              \
  return _eq_SxS_( A, B);                                                      \
}

#define MATCH( typ, postfix, zval, oval)                                       \
MATCH_AxA( typ, postfix, zval, oval)                                           \
MATCH_AxS( typ, postfix, zval, oval)                                           \
MATCH_SxA( typ, postfix, zval, oval)                                           \
MATCH_SxS( typ, postfix, zval, oval)

BUILT_IN( MATCH)


/******************************************************************************
 *
 * @fn <a>[n] mask( bool[n] p, <a>[n] A, <a>[n] B)
 *
 * @brief mask has the same semantics as where, but it does not use WLs.
 * These versions are defined on scalars/vectors only, but they could be
 * extended to higher-order arrays via a WL.
 *
 * @remark Unlike where, they compute both legs of the "conditional", which
 * may be a feature or a bug, depending on your point of view.
 *
 ******************************************************************************/

#define MASK_VxVxV( typ, postfix, zval, oval)                                  \
inline                                                                         \
typ[n] mask( bool[n] p, typ[n] A, typ[n] B)                                    \
{                                                                              \
  return _mask_VxVxV_( p, A, B);                                               \
}

#define MASK_VxVxS( typ, postfix, zval, oval)                                  \
inline                                                                         \
typ[n] mask( bool[n] p, typ[n] A, typ B)                                       \
{                                                                              \
  return _mask_VxVxS_( p, A, B);                                               \
}

#define MASK_VxSxV( typ, postfix, zval, oval)                                  \
inline                                                                         \
typ[n] mask( bool[n] p, typ A, typ[n] B)                                       \
{                                                                              \
  return _mask_VxSxV_( p, A, B);                                               \
}

#define MASK_VxSxS( typ, postfix, zval, oval)                                  \
inline                                                                         \
typ[n] mask( bool[n] p, typ A, typ B)                                          \
{                                                                              \
  return _mask_VxSxS_( p, A, B);                                               \
}

#define MASK_SxVxV( typ, postfix, zval, oval)                                  \
inline                                                                         \
typ[n] mask( bool p, typ[n] A, typ[n] B)                                       \
{                                                                              \
  return _mask_SxVxV_( p, A, B);                                               \
}

#define MASK_SxVxS( typ, postfix, zval, oval)                                  \
inline                                                                         \
typ[n] mask( bool p, typ[n] A, typ B)                                          \
{                                                                              \
  return _mask_SxVxS_( p, A, B);                                               \
}

#define MASK_SxSxV( typ, postfix, zval, oval)                                  \
inline                                                                         \
typ[n] mask( bool p, typ A, typ[n] B)                                          \
{                                                                              \
  return _mask_SxSxV_( p, A, B);                                               \
}

#define MASK_SxSxS( typ, postfix, zval, oval)                                  \
inline                                                                         \
typ mask( bool p, typ A, typ B)                                                \
{                                                                              \
  return _mask_SxSxS_( p, A, B);                                               \
}

#define MASK( typ, postfix, zval, oval)                                        \
MASK_VxVxV( typ, postfix, zval, oval)                                          \
MASK_VxVxS( typ, postfix, zval, oval)                                          \
MASK_VxSxV( typ, postfix, zval, oval)                                          \
MASK_SxVxV( typ, postfix, zval, oval)                                          \
MASK_SxVxS( typ, postfix, zval, oval)                                          \
MASK_SxSxV( typ, postfix, zval, oval)                                          \
MASK_SxSxS( typ, postfix, zval, oval)

// FIXME: Fix _mask_VxSxS_ in ct_prf.c
// MASK_VxSxS( typ, postfix, zval, oval)

BUILT_IN( MASK)
