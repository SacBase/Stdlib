module ArrayTransform;

use Constants: all;

export all;

#include "Templates.mac"

/******************************************************************************
 *
 * Structural OPS.
 *
 ******************************************************************************/

/******************************************************************************
 *
 * @fn <a>[n:v, m:ishp] take( int[n] v, typ[n:ohsp, m:ishp] A)
 *
 * @brief Takes a number of elements from the array, given a shape vector.
 *
 * @remark Take supports overtake
 *         E.g., take( [5], [2, 3]) =
 *           [2, 3, 0, 0, 0]
 *
 * @remark Take supports negative v, taking the last elements
 *         E.g., take( [-1], [2, 3]) =
 *           [3]
 *
 * @remark Take supports short v, padding the missing elements
 *         with corresponding elements from shp.
 *         E.g., take( [3], genarray( [2,2], 42)) =
 *           [[42, 42]
 *            [42, 42]
 *            [0,  0]]
 *
 ******************************************************************************/

#define TAKE( typ, postfix, zval, oval)                                        \
inline                                                                         \
typ[n:v, m:ishp] take( int[n] v, typ[n:oshp, m:ishp] A)                        \
{                                                                              \                                                                             
  /* Offset shows the index of the first element to be selected. */            \
  offset = where( _lt_VxS_(v, 0),                                              \
              _add_VxV_( oshp, v),                                             \
              0);                                                              \
  /*                                                                           \
   * Stop signals the location of the last index element of array.             \
   * This can be longer than the size of the array, in case offset             \
   * is less than (-oshp).                                                     \
  */                                                                           \
  stop = where( _lt_VxS_(v, 0),                                                \
            _abs_V_(v),                                                        \
            _min_VxV_( _abs_V_(v), oshp));                                     \
  /*                                                                           \
   * Start shows where the selection of array elements starts.                 \
   * This can only be different from offset if offset < (-oshp).               \
  */                                                                           \
  start = where( _lt_VxS_(_neg_V_(offset), 0),                                 \
            0,                                                                 \
            _neg_V_(offset));                                                  \
  /* The result is calculated in 2 steps: */                                   \
  res = {/* 1: select the required elements of the array */                    \
         iv -> array[ _add_VxV_( offset, iv)] | start <= iv < stop;            \         
         /* 2: add zeros around (if needed) */                                 \
         iv -> genarray(ishp, zval) | iv < _abs_V_(v)};                        \
  return(res);                                                                 \
}                                                                              \

BUILT_IN( TAKE)


/******************************************************************************
 *
 * @fn <a>[n:shp_res, m:ishp] drop( int[n] sv, <a>[n:oshp, m:ishp] A)
 *
 * @brief Drops a number of elements from the array, given a shape vector.
 *
 * @remark Drop supports overdrop
 *         E.g., drop( [5], [2, 3]) =
 *           []
 *
 * @remark Drop supports negative v, taking the last elements
 *         E.g., drop( [-1], [2, 3]) =
 *           [2]
 *
 * @remark Drop supports short v, padding the missing elements
 *         with corresponding elements from shp.
 *         E.g., drop( [1], genarray( [2,2], 42)) =
 *           [[42, 42]]
 *
 ******************************************************************************/

#define DROP( typ, postfix, zval, oval)                                        \
inline                                                                         \
typ[n:shp_res, m:ishp] drop( int[n] v, typ[n:oshp, m:ishp] array)              \                        
{                                                                              \
  /* Calculate shape of result array. */                                       \
  shp_res = _sub_VxV_(oshp, _abs_V_(v));                                       \
  shp_res = where( _lt_VxS_(shp_res, 0), 0, shp_res);                          \
  /* Start shows the index of the first element to be selected. */             \
  start = where( _lt_VxS_(v, 0), 0, v);                                        \
  /* Select the requested elements of array. */                                \
  res = { iv -> array[ _add_VxV_( start, iv)] | iv < shp_res };                \
  return(res);                                                                 \
}                                                                              \

BUILT_IN( DROP)


/******************************************************************************
 *
 * @fn <a>[d:shp] tile( int[d] shp, int[.] idx, <a>[*] A)
 *
 * @brief Takes a tile from the array, of shape shp from at index idx.
 *
 * @remark Tile supports overtile
 *         E.g., tile( [5], [1], [2, 3, 4]) =
 *           [3, 4, 0, 0, 0]
 *
 ******************************************************************************/

#define TILE( typ, postfix, zval, oval)                                        \
inline                                                                         \
typ[n:shp] tile( int[n] shp, int[n] idx, typ[n:shp_a] array)                   \
| _all_V_( _ge_VxS_(shp, 0))                                                   \
{                                                                              \
  /* Start shows how many elements we prepend before the array. */             \
  start = where( _lt_VxS_(idx, 0),                                             \
           _abs_V_(idx),                                                       \
           0);                                                                 \
  /*                                                                           \
   * Stop shows where our selection of the given array ends, or, in case       \
   * the selection goes beyond the array, where the array ends.                \
  */                                                                           \
  stop = _min_VxV_(shp, _sub_VxV_(shp_a, idx));                                \
  /* The result is calculated in 2 steps: */                                   \
  res = {/* 1: select the required elements of the array */                    \
         iv -> array[ _add_VxV_(idx, iv)] | start <= iv < stop;                \
         /* 2: add zeros around (if needed) */                                 \
         iv -> zval | iv < shp};                                               \
  return( res);                                                                \
}                                                                              \

BUILT_IN( TILE)


/******************************************************************************
 *
 * @fn <a>[o,d:shp] ++( <a>[n,d:shp] A, <a>[m,d:shp] B)
 *
 * @brief First-axis catenation.
 *
 ******************************************************************************/

#define CAT_AxA( typ, postfix, zval, oval)                                     \
inline                                                                         \
typ[o, d:shp] ++( typ[n, d:shp] A, typ[m, d:shp] B)                            \
{                                                                              \
  o = _add_SxS_(n, m);                                                         \
  res = {[i] -> A[i] | [i] < [n];                                              \
         [i] -> B[ _sub_SxS_(i, n)] | [n] <= [i] < [o]};                       \
  return res;                                                                  \
}

#define CAT_AxS( typ, postfix, zval, oval)                                     \
inline                                                                         \
typ[o, d:shp] ++( typ[n, d:shp] A, typ B)                                      \
{                                                                              \
  o = _add_SxS_(n, 1);                                                         \
  res = {[i] -> A[i] | [i] < [n];                                              \
         [i] -> genarray(shp, B) | [n] <= [i] < [o]};                          \
  return res;                                                                  \
}

#define CAT_SxA( typ, postfix, zval, oval)                                     \
inline                                                                         \
typ[o, d:shp] ++( typ A, typ[m, d:shp] B)                                      \
{                                                                              \
  o = _add_SxS_( 1, m);                                                        \
  res = with {                                                                 \
          ([0] <= [i] < [1]) : genarray(shp, A);                               \
          ([1] <= [i] < [o]) : B[ _sub_SxS_(i, 1)];                            \
        } : genarray( [o], genarray(shp, zval));                               \
  return res;                                                                  \
}

#define CAT_SxS( typ, postfix, zval, oval)                                     \
inline                                                                         \
typ[2] ++( typ A, typ B)                                                       \
{                                                                              \
  return [A, B];                                                               \
}

#define CAT( typ, postfix, zval, oval)                                         \
CAT_AxA( typ, postfix, zval, oval)                                             \
CAT_AxS( typ, postfix, zval, oval)                                             \
CAT_SxA( typ, postfix, zval, oval)                                             \
CAT_SxS( typ, postfix, zval, oval)

BUILT_IN( CAT)


/******************************************************************************
 *
 * @fn <a>[d:shp,o] ++( <a>[d:shp,n] A, <a>[d:shp,m] B)
 *
 * @brief Last-axis catenation. We assume that A and B are the same shape,
 * except perhaps along the last axis.
 *
 ******************************************************************************/

#define CATENATE_AxA( typ, postfix, zval, oval)                                \
inline                                                                         \
typ[d:shp,o] catenate( typ[d:shp,n] A, typ[d:shp,m] B)                         \                      
{                                                                              \
  o = _add_SxS_( n, m);                                                        \
  res = { iv -> _cat_VxV_( A[iv], B[iv]) | iv < shp };                         \
  return res;                                                                  \
}

#define CATENATE_AxS( typ, postfix, zval, oval)                                \
inline                                                                         \
typ[d:shp,o] catenate( typ[d:shp,n] A, typ B)                                  \                       
{                                                                              \
  o = _add_SxS_( n, 1);                                                        \
  res = { iv -> _cat_VxV_( A[iv], [B]) | iv < shp };                           \
  return res;                                                                  \
}

#define CATENATE_SxA( typ, postfix, zval, oval)                                \
inline                                                                         \
typ[d:shp,o] catenate( typ A, typ[d:shp,m] B)                                  \                      
{                                                                              \
  o = _add_SxS_( 1, m);                                                        \
  res = { iv -> _cat_VxV_( [A], B[iv]) | iv < shp };                           \
  return res;                                                                  \
}

#define CATENATE_SxS( typ, postfix, zval, oval)                                \
inline                                                                         \
typ[2] catenate( typ A, typ B)                                                 \
{                                                                              \
  return [A, B];                                                               \
}

#define CATENATE( typ, postfix, zval, oval)                                    \
CATENATE_AxA( typ, postfix, zval, oval)                                        \
CATENATE_AxS( typ, postfix, zval, oval)                                        \
CATENATE_SxA( typ, postfix, zval, oval)                                        \
CATENATE_SxS( typ, postfix, zval, oval)

BUILT_IN( CATENATE)


/******************************************************************************
 *
 * @fn <a>[n,d:shp] reverse( <a>[n,d:shp] A)
 *
 * @brief First-axis reverse.
 *
 ******************************************************************************/

#define REVERSE( typ, postfix, zval, oval)                                     \
inline                                                                         \
typ[n,d:shp] reverse( typ[n,d:shp] A)                                          \
{                                                                              \
  max = _sub_SxS_( n, 1);                                                      \
  res = { [i] -> A[ _sub_SxS_( max, i)] | [i] <= [max] };                      \
  return res;                                                                  \
}

BUILT_IN( REVERSE)


/******************************************************************************
 *
 * @fn <a>[d:shp] reverse( int axis, <a>[d:shp] A)
 *
 * @brief Reverse on specified axis: 0 is leading axis, dim-1 is trailing axis.
 *
 ******************************************************************************/

#define REVERSEAXIS( typ, postfix, zval, oval)                                 \
inline                                                                         \
typ[axis:oshp, n, d:shp] reverse( int axis, typ[axis:oshp, n, d:shp] A)        \
{                                                                              \
  res = { iv -> reverse( A[iv]) | iv < oshp };                                 \
  return res;                                                                  \
}

BUILT_IN( REVERSEAXIS)


/******************************************************************************
 *
 * @fn <a>[d:shpT] transpose( <a>[d:shp] A)
 *
 * @brief transposes the given array.
 *
 ******************************************************************************/

#define TRANSPOSE( typ, postfix, zval, oval)                                   \
inline                                                                         \
typ[d:shpT] transpose( typ[d:shp] A)                                           \
{                                                                              \
  shpT = reverse(shp);                                                         \
  res = { iv -> A[ reverse(iv)] | iv < shpT };                                 \
  return res;                                                                  \
}

BUILT_IN( TRANSPOSE)


/******************************************************************************
 *
 * @fn <a>[d:shp] shift (int dim, int count, typ boundary, <a>[d:shp] A)
 *
 * @brief shifts the given array. Positive shift is to right, negative to left.
 *
 ******************************************************************************/

#define SHIFT_S( typ, postfix, zval, oval)                                     \
inline                                                                         \
typ[dim:oshp, n, d:ishp] myshift2                                              \
( int dim, int count, typ boundary, typ[dim:oshp, n, d:ishp] A)                \
{                                                                              \
  res = { iv ->                                                                \
      { [i] -> ( _lt_SxS_( _sub_SxS_( i, count), n )                           \
              && _ge_SxS_( _sub_SxS_( i, count), 0) )                          \
      ? A[ _cat_VxV_( iv, [ _sub_SxS_( i, count)] ) ]                          \
      : genarray( ishp, boundary) | [i] < [n] }                                \
    | iv < oshp };                                                             \
  return res;                                                                  \
}


#define SHIFT_V( typ, postfix, zval, oval)                                     \
inline                                                                         \
typ[n:oshp, m:ishp] shift( int[n] counts, typ boundary, typ[n:oshp, m:ishp] A) \
{                                                                              \
  counts_ext = _cat_VxV_( counts, genarray( [m], 0));                          \
                                                                               \
  shp = _cat_VxV_( oshp, ishp);                                                \
  idx = _neg_V_( counts_ext);                                                  \
                                                                               \
  /*                                                                           \
   * The next section is taken from tile_apl. This can be replaced if          \
   * tile_apl becomes an official part of this library                         \
  */                                                                           \
                                                                               \
  /* Start shows how many elements we prepend before the array. */             \
  start = where( _lt_VxS_(idx, 0),                                             \
           _abs_V_(idx),                                                       \
           0);                                                                 \
  /*                                                                           \
   * Stop shows where our selection of the given array ends, or, in case       \
   * the selection goes beyond the array, where the array ends.                \
  */                                                                           \
  stop = _min_VxV_(shp, _sub_VxV_(shp, idx));                                  \
  /* The result is calculated in 2 steps: */                                   \
  res = {/* 1: select the required elements of the array */                    \
         iv -> A[ _add_VxV_(idx, iv)] | start <= iv < stop;                    \
         /* 2: add zeros around */                                             \
         iv -> zval | iv < shp};                                               \
  return res;                                                                  \
}

#define SHIFT_VZ( typ, postfix, zval, oval)                                    \
inline                                                                         \
typ[n:oshp, m:ishp] shift( int[n] counts, typ[n:oshp, m:ishp] A)               \
{                                                                              \
  return shift( counts, zval, A);                                              \
}

#define SHIFT( typ, postfix, zval, oval)                                       \
SHIFT_S( typ, postfix, zval, oval)                                             \
SHIFT_V( typ, postfix, zval, oval)                                             \
SHIFT_VZ( typ, postfix, zval, oval)

BUILT_IN( SHIFT)


/******************************************************************************
 *
 * @fn <a>[d:shp] rotate( int dim, int count, <a>[d:shp] A)
 *
 * @brief Rotates the given array, wrapping values that go out of bounds.
 * Positive rotate is to right, negative to left.
 *
 * @example rotate( [2], iota( 5)) = [3, 4, 0, 1, 2]
 *
 * @remark The definition of ROTATE_V is poor: it will never WLF/AWLF on arrays
 * of rank > 2, because maxlur = 2, by default. Better just to use compositions
 * of rotates, I think, but if you're keen, then use -maxlur 42 or something
 * like that.
 *
 ******************************************************************************/

#define ROTATE_S( typ, postfix, zval, oval)                                    \
inline                                                                         \
typ[dim:oshp, n, d:ishp] rotate                                                \
( int dim, int count, typ[dim:oshp, n, d:ishp] A)                              \
{                                                                              \
  res = { iv ->                                                                \
      { [i] ->                                                                 \
        A[ _cat_VxV_( iv, [ _aplmod_SxS_ ( _sub_SxS_( i, count), n )] ) ]      \
        | [i] < [n] }                                                          \
    | iv < oshp };                                                             \
  return res;                                                                  \
}

#define ROTATE_V( typ, postfix, zval, oval)                                    \
inline                                                                         \
typ[n:oshp, m:ishp] rotate (int[n] counts, typ[n:oshp, m:ishp] A)              \
{                                                                              \
  res = { iv ->                                                                \
      A[ { [i] -> _aplmod_SxS_( _sub_SxS_(iv[i], counts[i]), oshp[i])          \
      | [i] < [n] } ]                                                          \
    | iv < oshp };                                                             \
  return res;                                                                  \
}

#define ROTATE( typ, postfix, zval, oval)                                      \
ROTATE_S( typ, postfix, zval, oval)                                            \
ROTATE_V( typ, postfix, zval, oval)

BUILT_IN( ROTATE)


/******************************************************************************
 *
 * @fn <a>[d:shp] where( bool[d:shp] p, <a>[d:shp] A, <a>[d:shp] B)
 *
 * @brief Selects the element from A if the corresponding value of p is true,
 * otherwise selects the element from B.
 *
 ******************************************************************************/

#define WHERE_AxA( typ, postfix, zval, oval)                                   \
inline                                                                         \
typ[d:shp] where( bool[d:shp] p, typ[d:shp] A, typ[d:shp] B)                   \
{                                                                              \
  return { iv -> _sel_VxA_( iv, p) ? _sel_VxA_( iv, A) : _sel_VxA_( iv, B) };  \
}

#define WHERE_AxS( typ, postfix, zval, oval)                                   \
inline                                                                         \
typ[d:shp] where( bool[d:shp] p, typ[d:shp] A, typ B)                          \
{                                                                              \
  return { iv -> _sel_VxA_( iv, p) ? _sel_VxA_( iv, A) : B };                  \
}

#define WHERE_SxA( typ, postfix, zval, oval)                                   \
inline                                                                         \
typ[d:shp] where( bool[d:shp] p, typ A, typ[d:shp] B)                          \
{                                                                              \
  return { iv -> _sel_VxA_( iv, p) ? A : _sel_VxA_( iv, B) };                  \
}

#define WHERE_SxS( typ, postfix, zval, oval)                                   \
inline                                                                         \
typ[b:shp] where( bool[b:shp] p, typ A, typ B)                                 \
{                                                                              \
  return { iv -> _sel_VxA_( iv, p) ? A : B };                                  \
}

#define WHERE( typ, postfix, zval, oval)                                       \
WHERE_AxA( typ, postfix, zval, oval)                                           \
WHERE_AxS( typ, postfix, zval, oval)                                           \
WHERE_SxA( typ, postfix, zval, oval)                                           \
WHERE_SxS( typ, postfix, zval, oval)

BUILT_IN( WHERE)


/******************************************************************************
 *
 * @fn <a> reduce( <a>[d:shp] A)
 *
 * @brief Reduces the given array to a single element.
 *
 ******************************************************************************/

#define REDUCE( name, typ, fun, neutral)                                       \
inline                                                                         \
typ name( typ[d:shp] A)                                                        \
{                                                                              \
  res = with {                                                                 \
          (_mul_SxV_( 0, shp) <= iv < shp) : _sel_VxA_( iv, A);                \
        } : fold( fun, neutral);                                               \
  return res;                                                                  \
}

#define NUM_REDUCE( typ, postfix, zval, oval)                                  \
REDUCE( sum, typ, ScalarArith::+, zval)                                        \
REDUCE( prod, typ, ScalarArith::*, oval)                                       \
REDUCE( maxval, typ, ScalarArith::max, min##typ())                             \
REDUCE( minval, typ, ScalarArith::min, max##typ())

NUM( NUM_REDUCE)

#define BOOL_REDUCE                                                            \
REDUCE( all, bool, ScalarArith::&, true)                                       \
REDUCE( any, bool, ScalarArith::|, false)

BOOL_REDUCE


/******************************************************************************
 *
 * @fn bool match( <a>[n:shpA] A, <a>[m:shpB] B)
 *
 * @brief whether the given arrays are equal.
 *
 ******************************************************************************/

#define MATCH_AxA( typ, postfix, zval, oval)                                   \
inline                                                                         \
bool match( typ[n:shpA] A, typ[m:shpB] B)                                      \
{                                                                              \
  res = _eq_SxS_( n, m)                                                        \
     && _all_V_( _eq_VxV_( shpA, shpB))                                        \
     && with {                                                                 \
          (_mul_SxV_( 0, shpA) <= iv < shpA)                                   \
            : _eq_SxS_( _sel_VxA_( iv, A), _sel_VxA_( iv, B));                 \
        } : foldfix( ScalarArith::&, true, false);                             \
  return res;                                                                  \
}

#define MATCH_AxS( typ, postfix, zval, oval)                                   \
inline                                                                         \
bool match( typ[+] A, typ B)                                                   \
{                                                                              \
  return false;                                                                \
}

#define MATCH_SxA( typ, postfix, zval, oval)                                   \
inline                                                                         \
bool match( typ A, typ[+] B)                                                   \
{                                                                              \
  return false;                                                                \
}

#define MATCH_SxS( typ, postfix, zval, oval)                                   \
inline                                                                         \
bool match( typ A, typ B)                                                      \
{                                                                              \
  return _eq_SxS_( A, B);                                                      \
}

#define MATCH( typ, postfix, zval, oval)                                       \
MATCH_AxA( typ, postfix, zval, oval)                                           \
MATCH_AxS( typ, postfix, zval, oval)                                           \
MATCH_SxA( typ, postfix, zval, oval)                                           \
MATCH_SxS( typ, postfix, zval, oval)

BUILT_IN( MATCH)


/******************************************************************************
 *
 * @fn <a>[n] mask( bool[n] p, <a>[n] A, <a>[n] B)
 *
 * @brief mask has the same semantics as where, but it does not use WLs.
 * These versions are defined on scalars/vectors only, but they could be
 * extended to higher-order arrays via a WL.
 *
 * @remark Unlike where, they compute both legs of the "conditional", which
 * may be a feature or a bug, depending on your point of view.
 *
 ******************************************************************************/

#define MASK_VxVxV( typ, postfix, zval, oval)                                  \
inline                                                                         \
typ[n] mask( bool[n] p, typ[n] A, typ[n] B)                                    \
{                                                                              \
  return _mask_VxVxV_( p, A, B);                                               \
}

#define MASK_VxVxS( typ, postfix, zval, oval)                                  \
inline                                                                         \
typ[n] mask( bool[n] p, typ[n] A, typ B)                                       \
{                                                                              \
  return _mask_VxVxS_( p, A, B);                                               \
}

#define MASK_VxSxV( typ, postfix, zval, oval)                                  \
inline                                                                         \
typ[n] mask( bool[n] p, typ A, typ[n] B)                                       \
{                                                                              \
  return _mask_VxSxV_( p, A, B);                                               \
}

#define MASK_VxSxS( typ, postfix, zval, oval)                                  \
inline                                                                         \
typ[n] mask( bool[n] p, typ A, typ B)                                          \
{                                                                              \
  return _mask_VxSxS_( p, A, B);                                               \
}

#define MASK_SxVxV( typ, postfix, zval, oval)                                  \
inline                                                                         \
typ[n] mask( bool p, typ[n] A, typ[n] B)                                       \
{                                                                              \
  return _mask_SxVxV_( p, A, B);                                               \
}

#define MASK_SxVxS( typ, postfix, zval, oval)                                  \
inline                                                                         \
typ[n] mask( bool p, typ[n] A, typ B)                                          \
{                                                                              \
  return _mask_SxVxS_( p, A, B);                                               \
}

#define MASK_SxSxV( typ, postfix, zval, oval)                                  \
inline                                                                         \
typ[n] mask( bool p, typ A, typ[n] B)                                          \
{                                                                              \
  return _mask_SxSxV_( p, A, B);                                               \
}

#define MASK_SxSxS( typ, postfix, zval, oval)                                  \
inline                                                                         \
typ mask( bool p, typ A, typ B)                                                \
{                                                                              \
  return _mask_SxSxS_( p, A, B);                                               \
}

#define MASK( typ, postfix, zval, oval)                                        \
MASK_VxVxV( typ, postfix, zval, oval)                                          \
MASK_VxVxS( typ, postfix, zval, oval)                                          \
MASK_VxSxV( typ, postfix, zval, oval)                                          \
MASK_SxVxV( typ, postfix, zval, oval)                                          \
MASK_SxVxS( typ, postfix, zval, oval)                                          \
MASK_SxSxV( typ, postfix, zval, oval)                                          \
MASK_SxSxS( typ, postfix, zval, oval)

// FIXME: Fix _mask_VxSxS_ in ct_prf.c
// MASK_VxSxS( typ, postfix, zval, oval)

BUILT_IN( MASK)
