module ComplexBasics;

export all;

typedef double[2] complex;

/******************************************************************************
 *
 * Extract real and imaginary part from a complex number.
 *
 ******************************************************************************/

inline double real(complex c)
{
    return ArrayBasics::sel([0], (double[2])c);
}

inline double imag(complex c)
{
    return ArrayBasics::sel([1], (double[2])c);
}

/******************************************************************************
 *
 * Functions for composing of complex numbers.
 *
 ******************************************************************************/

inline complex toc(int r, int i)
{
    return (complex)[ScalarArith::tod(r), ScalarArith::tod(i)];
}

inline complex toc(float r, float i)
{
    return (complex)[ScalarArith::tod(r), ScalarArith::tod(i)];
}

inline complex toc(double r, double i)
{
    return (complex)[r, i];
}

inline complex toc(double[2] c)
{
    return (complex)c;
}

inline complex toc(int r)
{
    return (complex)[ScalarArith::tod(r), 0d];
}

inline complex toc(float r)
{
    return (complex)[ScalarArith::tod(r), 0d];
}

inline complex toc(double r)
{
    return (complex)[r, 0d];
}

/******************************************************************************
 *
 * Functions for decomposing of complex numbers.
 *
 ******************************************************************************/

inline int, int toi(complex c)
{
    r = ScalarArith::toi(real(c));
    i = ScalarArith::toi(imag(c));
    return (r, i);
}

inline float, float tof(complex c)
{
    r = ScalarArith::tof(real(c));
    i = ScalarArith::tof(imag(c));
    return (r, i);
}

inline double, double tod(complex c)
{
    r = real(c);
    i = imag(c);
    return (r, i);
}

inline double[2] todv(complex c)
{
    return [real(c), imag(c)];
}

inline String::string tos(complex c)
{
    r, i = tod(c);
    res = String::sprintf("%f + %fi\n", r, i);
    return res;
}

inline int, int ptoi(complex c)
{
    x, y = ptof(c);
    r = ScalarArith::toi(x);
    i = ScalarArith::toi(y);
    return (r, i);
}

inline float, float ptof(complex c)
{
    x, y = tof(c);
    r = Math::sqrt(ScalarArith::tof(norm(c)));
    i = Math::atan2(x, y);
    return (r, i);
}

inline double, double ptod(complex c)
{
    x, y = tod(c);
    r = Math::sqrt(norm(c));
    i = Math::atan2(x, y);
    return (r, i);
}

/******************************************************************************
 *
 * Functions for (de)composing of complex numbers using polar coordinates.
 *
 ******************************************************************************/

inline complex polar(double mag, double angle)
{
    r = mag ScalarArith::* Math::cos(angle);
    i = mag ScalarArith::* Math::sin(angle);
    return toc(r, i);
}

inline complex polar(double mag)
{
    return toc(mag);
}

inline double normSq(complex c)
{
    r, i = tod(c);
    x = r ScalarArith::* r;
    y = i ScalarArith::* i;
    res = x ScalarArith::+ y;
    return res;
}

inline double norm(complex c)
{
    return Math::sqrt(normSq(c));
}

inline double arg(complex c)
{
    r, i = tod(c);
    res = Math::atan2(r, i);
    return res;
}

/******************************************************************************
 *
 * Complex constants.
 *
 ******************************************************************************/

inline complex i()
{
    return toc(0d, 1d);
}

inline complex zero()
{
    return toc(0d, 0d);
}

inline complex one()
{
    return toc(1d, 0d);
}

inline complex zero(complex[*] c)
{
    // Provided for compatibility with UDT macro mechanism
    return toc(0d, 0d);
}

inline complex one(complex[*] c)
{
    // Provided for compatibility with UDT macro mechanism
    return toc(1d, 0d);
}
