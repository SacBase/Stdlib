module ComplexBasics;

export all;

typedef double[2] complex;

/******************************************************************************
 *
 * Extract real and imaginary part from a complex number.
 *
 ******************************************************************************/

inline double real(complex arr)
{
    return Array::sel([0], (double[2])arr);
}

inline double imag(complex arr)
{
    return Array::sel([1], (double[2])arr);
}

/******************************************************************************
 *
 * Functions for composing of complex numbers.
 *
 ******************************************************************************/

inline complex toc(int r, int i)
{
    return (complex)[ScalarArith::tod(r), ScalarArith::tod(i)];
}

inline complex toc(float r, float i)
{
    return (complex)[ScalarArith::tod(r), ScalarArith::tod(i)];
}

inline complex toc(double r, double i)
{
    return (complex)[r, i];
}

inline complex toc(double[2] arr)
{
    return (complex)arr;
}

inline complex toc(int r)
{
    return (complex)[ScalarArith::tod(r), 0d];
}

inline complex toc(float r)
{
    return (complex)[ScalarArith::tod(r), 0d];
}

inline complex toc(double r)
{
    return (complex)[r, 0d];
}

/******************************************************************************
 *
 * Functions for decomposing of complex numbers.
 *
 ******************************************************************************/

inline int, int toi(complex arr)
{
    r = ScalarArith::toi(real(arr));
    i = ScalarArith::toi(imag(arr));
    return (r, i);
}

inline float, float tof(complex arr)
{
    r = ScalarArith::tof(real(arr));
    i = ScalarArith::tof(imag(arr));
    return (r, i);
}

inline double, double tod(complex arr)
{
    r = real(arr);
    i = imag(arr);
    return (r, i);
}

inline double[2] todv(complex arr)
{
    return [real(arr), imag(arr)];
}

inline String::string tos(complex arr)
{
    r, i = tod(arr);
    res = String::sprintf("%f + %fi\n", r, i);
    return res;
}

inline int, int ptoi(complex arr)
{
    x, y = ptof(arr);
    r = ScalarArith::toi(x);
    i = ScalarArith::toi(y);
    return (r, i);
}

inline float, float ptof(complex arr)
{
    x, y = tof(arr);
    r = Math::sqrt(ScalarArith::tof(norm(arr)));
    i = Math::atan2(x, y);
    return (r, i);
}

inline double, double ptod(complex arr)
{
    x, y = tod(arr);
    r = Math::sqrt(norm(arr));
    i = Math::atan2(x, y);
    return (r, i);
}

/******************************************************************************
 *
 * Functions for (de)composing of complex numbers using polar coordinates.
 *
 ******************************************************************************/

inline complex polar(double mag, double angle)
{
    r = mag ScalarArith::* Math::cos(angle);
    i = mag ScalarArith::* Math::sin(angle);
    return toc(r, i);
}

inline complex polar(double mag)
{
    return toc(mag);
}

inline double normSq(complex arr)
{
    r, i = tod(arr);
    x = r ScalarArith::* r;
    y = i ScalarArith::* i;
    res = x ScalarArith::+ y;
    return res;
}

inline double norm(complex arr)
{
    return Math::sqrt(normSq(arr));
}

inline double arg(complex arr)
{
    r, i = tod(arr);
    res = Math::atan2(r, i);
    return res;
}

/******************************************************************************
 *
 * Complex constants.
 *
 ******************************************************************************/

inline complex i()
{
    return toc(0d, 1d);
}

inline complex zero()
{
    return toc(0d, 0d);
}

inline complex one()
{
    return toc(1d, 0d);
}

inline complex zero(complex[*] arr)
{
    // Provided for compatibility with UDT macro mechanism
    return toc(0d, 0d);
}

inline complex one(complex[*] arr)
{
    // Provided for compatibility with UDT macro mechanism
    return toc(1d, 0d);
}
