module ComplexBasics;

#define OVERLOADS toi,tof,tod,zero,one
use Array: all except { OVERLOADS };
import Array: { OVERLOADS };

export all;

typedef double[2] complex;

/******************************************************************************
 *
 * Extract real and imaginary part from a complex number.
 *
 ******************************************************************************/

inline
double real( complex A)
{
  return ((double[2])A)[0];
}

inline
double imag( complex A)
{
  return ((double[2])A)[1];
}

/******************************************************************************
 *
 * Functions for composing of complex numbers.
 *
 ******************************************************************************/

inline
complex toc( int r, int i)
{
  return (complex)[ScalarArith::tod( r), ScalarArith::tod( i)];
}

inline
complex toc( float r, float i)
{
  return (complex)[ScalarArith::tod( r), ScalarArith::tod( i)];
}

inline
complex toc( double r, double i)
{
  return (complex)[r, i];
}

inline
complex toc( double[2] A)
{
  return (complex)A;
}

inline
complex toc( int r)
{
  return (complex)[ScalarArith::tod( r), 0d];
}

inline
complex toc( float r)
{
  return (complex)[ScalarArith::tod( r), 0d];
}

inline
complex toc( double r)
{
  return (complex)[r, 0d];
}

/******************************************************************************
 *
 * Functions for decomposing of complex numbers.
 *
 ******************************************************************************/

inline
int, int toi( complex A)
{
  r = ScalarArith::toi( real( A));
  i = ScalarArith::toi( imag( A));
  return (r, i);
}

inline
float, float tof( complex A)
{
  r = ScalarArith::tof( real( A));
  i = ScalarArith::tof( imag( A));
  return (r, i);
}

inline
double, double tod( complex A)
{
  r = real( A);
  i = imag( A);
  return (r, i);
}

inline
double[2] todv( complex A)
{
  return [real( A), imag( A)];
}

inline
String::string tos( complex A)
{
  r, i = tod( A);
  res = String::sprintf( "%f + %fi\n", r, i);
  return res;
}

inline
int, int ptoi( complex A)
{
  x, y = ptof( A);
  r = ScalarArith::toi( x);
  i = ScalarArith::toi( y);
  return (r, i);
}

inline
float, float ptof( complex A)
{
  x, y = tof( A);
  r = Math::sqrt( ScalarArith::tof( norm( A)));
  i = Math::atan2( x, y);
  return (r, i);
}

inline
double, double ptod( complex A)
{
  x, y = tod( A);
  r = Math::sqrt( norm( A));
  i = Math::atan2( x, y);
  return (r, i);
}

/******************************************************************************
 *
 * Functions for (de)composing of complex numbers using polar coordinates.
 *
 ******************************************************************************/

inline
complex polar( double mag, double angle)
{
  r = _mul_SxS_( mag, Math::cos( angle));
  i = _mul_SxS_( mag, Math::sin( angle));
  return toc( r, i);
}

inline
complex polar( double mag)
{
  return toc( mag);
}

inline
double normSq( complex A)
{
  r, i = tod( A);
  x = _mul_SxS_( r, r);
  y = _mul_SxS_( i, i);
  res = _add_SxS_( x, y);
  return res;
}

inline
double norm( complex A)
{
  return Math::sqrt( normSq( A));
}

inline
double arg( complex A)
{
  r, i = tod( A);
  res = Math::atan2( r, i);
  return res;
}

/******************************************************************************
 *
 * Complex constants.
 *
 ******************************************************************************/

inline
complex i()
{
  return toc( 0d, 1d);
}

inline
complex zero()
{
  return toc( 0d, 0d);
}

inline
complex zero( complex[*] A)
{
  // Provided for compatibility with UDT macro mechanism
  return toc( 0d, 0d);
}

inline
complex one()
{
  return toc( 1d, 0d);
}

inline
complex one( complex[*] A)
{
  // Provided for compatibility with UDT macro mechanism
  return toc( 1d, 0d);
}
