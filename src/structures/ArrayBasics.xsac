module ArrayBasics;

export all;

#include "Templates.mac"

/******************************************************************************
 *
 * @fn int dim( <a>[d:shp] A)
 *
 * @brief Yields an array's dimensionality.
 *
 ******************************************************************************/

#define DIM( typ, postfix, zval, oval)                                         \
inline                                                                         \
int dim( typ[d:shp] A)                                                         \
{                                                                              \
  return d;                                                                    \
}

BUILT_IN( DIM)


/******************************************************************************
 *
 * @fn int[d] shape( <a>[d:shp] A)
 *
 * @brief Yields an array's shape vector.
 *
 ******************************************************************************/

#define SHAPE( typ, postfix, zval, oval)                                       \
inline                                                                         \
int[d] shape( typ[d:shp] A)                                                    \
{                                                                              \
  return shp;                                                                  \
}

BUILT_IN( SHAPE)


/******************************************************************************
 *
 * @fn <a>[*] sel(int[vlen] idx, <a>[vlen:vshp,d:shp] A)
 *
 * @brief Selects the subarray of the array at position idx, provided the index
 * vector is no longer than the rank of the array, and each index element is no
 * longer than the corresponding array shape element.
 *
 ******************************************************************************/

#define SEL_VxA( typ, postfix, zval, oval)                                     \
inline                                                                         \
typ[d:shp] sel( int[vlen] idx, typ[vlen:vshp,d:shp] A)                         \
  | _all_V_( _le_SxV_( 0, idx)), _all_V_( _lt_VxV_( idx, vshp))                \
{                                                                              \
  return { iv -> _sel_VxA_( _cat_VxV_( idx, iv), A) | iv < shp };              \
}

#define SEL_SxA( typ, postfix, zval, oval)                                     \
inline                                                                         \
typ[d:shp] sel( int idx, typ[n,d:shp] A)                                       \
  | _le_SxS_( 0, idx), _lt_SxS_( idx, n)                                       \
{                                                                              \
  return sel( [idx], A);                                                       \
}

#define SEL( typ, postfix, zval, oval)                                         \
SEL_VxA( typ, postfix, zval, oval)                                             \
SEL_SxA( typ, postfix, zval, oval)

BUILT_IN( SEL)


/******************************************************************************
 *
 * @fn <a>[d:shp] reshape( int[d] shp, <a>[o:oshp] A)
 *
 * @brief Creates a new array with identical data vector but new shape, provided
 * the length of the data vector matches the product of the new shape vector.
 *
 ******************************************************************************/

#define RESHAPE( typ, postfix, zval, oval)                                     \
inline                                                                         \
typ[d:shp] reshape( int[d] shp, typ[o:oshp] A)                                 \
{                                                                              \
  return _reshape_VxA_( shp, A);                                               \
}

BUILT_IN( RESHAPE)


/******************************************************************************
 *
 * @fn <a>[n:shp,d:vshp] genarray( int[n] shp, <a>[d:vshp] value)
 *
 * @brief Generates a new array from the given shape and default value.
 *
 ******************************************************************************/

#define GENARRAY( typ, postfix, zval, oval)                                    \
inline                                                                         \
typ[n:shp,d:vshp] genarray( int[n] shp, typ[d:vshp] value)                     \
{                                                                              \
  return { iv -> value | iv < shp };                                           \
}

BUILT_IN( GENARRAY)


/******************************************************************************
 *
 * @fn <a>[d:shp] modarray( <a>[d:shp] A, int[d] idx, <a> value)
 *
 * @brief modifies the element of the array at position idx.
 *
 ******************************************************************************/

#define MODARRAY_AxVxA( typ, postfix, zval, oval)                              \
inline                                                                         \
typ[vlen:vshp,d:shp]                                                           \
modarray( typ[vlen:vshp,d:shp] A, int[vlen] idx, typ[d:shp] value)             \
  | _all_V_( _le_SxV_( 0, idx)), _all_V_( _lt_VxV_( idx, shp))                 \
{                                                                              \
  res = with {                                                                 \
          (idx <= iv <= idx) : value;                                          \
        } : modarray( A);                                                      \
  return res;                                                                  \
}

#define MODARRAY_AxVxS( typ, postfix, zval, oval)                              \
inline                                                                         \
typ[d:shp] modarray( typ[d:shp] A, int[d] idx, typ value)                      \
  | _all_V_( _le_SxV_( 0, idx)), _all_V_( _lt_VxV_( idx, shp))                 \
{                                                                              \
  return _modarray_AxVxS_( A, idx, value);                                     \
}

#define MODARRAY_AxSxA( typ, postfix, zval, oval)                              \
inline                                                                         \
typ[n,d:shp] modarray( typ[n,d:shp] A, int idx, typ[d:shp] value)              \
  | _le_SxS_( 0, idx), _lt_SxS_( idx, n)                                       \
{                                                                              \
  return modarray( A, [idx], value);                                           \
}

#define MODARRAY( typ, postfix, zval, oval)                                    \
MODARRAY_AxVxA( typ, postfix, zval, oval)                                      \
MODARRAY_AxVxS( typ, postfix, zval, oval)                                      \
MODARRAY_AxSxA( typ, postfix, zval, oval)

BUILT_IN( MODARRAY)


/******************************************************************************
 *
 * @fn int[d:shp,d] iota( int[d] shp)
 *
 * @brief Creates an array of the given shape with values ranging from 0 to d.
 *
 ******************************************************************************/

inline
int[d:shp,d] iota( int[d] shp)
{
  return { iv -> iv | iv < shp };
}

inline
int[d] iota( int d)
{
  return { [i] -> i | [i] < [d] };
}
