module ArrayFormat;

use Array: all;
use MathArray: { log10 };
use String: { tochar, sprintf };

export { format };

#include "Templates.mac"

// This is a crude workaround for issue #2333, which Bodo
// suggests requires major redesign of modules.
#define DOINL inline

/******************************************************************************
 *
 * APL Array formatting functions.
 *
 * These functions generate character representations of SAC arrays for
 * APL-based code. The functions come in several classes:
 *   - Default formatting: array elements are formatted to the minimum width
 *     that does not lose precision.
 *   - Defined formatting to specified precision, p: array elements are
 *     formatted to p significant digits.
 *   - Defined formatting: array elements are formatted to specified
 *     precision and width. If a result element does not fit within width,
 *     that element is replaced by '*'.
 *
 ******************************************************************************/

/******************************************************************************
 *
 * @fn char[d:shp] format( char[d:shp] A)
 *
 * @brief Default format for any character array.
 *
 ******************************************************************************/
DOINL
char[d:shp] format( char[d:shp] A)
{
  return( A);
}


/******************************************************************************
 *
 * @fn char[1] format( bool A)
 *
 * @brief Default format for boolean scalar.
 *
 ******************************************************************************/
DOINL
char[1] format( bool A)
{
  res = A ? '1' : '0';
  return( [res]);
}

/******************************************************************************
 *
 * @fn char[+] format( bool[d:shp] A)
 *
 * Default format for boolean non-scalars.
 *
 ******************************************************************************/
DOINL
char[+] format( bool[d:shp] A)
{
  res = with {
        (. <= iv <= .)
          : A[ iv] ? ['1', ' '] : ['0', ' '];
      } : genarray( shp);
  zs = drop( [-2], shape( res));
  zs = zs ++ [prod( take( [-2], shape( res)))];
  res = reshape( zs, res);
  lastcol = genarray( [dim( res)], 0);
  lastcol = modarray( lastcol, dim( res) - 1, -1);
  res = drop( lastcol, res);
  return( res);
}

/******************************************************************************
 *
 * @fn char[.] format( bool A, int[2] w)
 *
 * @brief Defined-width and precision format on boolean scalar.
 *
 * @param w[0] The maximum legal result width. If result is wider than this,
 *        the result will be filled with asterixs ('*').
 * @param w[1] The number of significant digits to be printed.
 *
 ******************************************************************************/
DOINL
char[.] format( bool A, int[2] w)
{
  res = format( tod( A), w);
  return( res);
}

/******************************************************************************
 *
 * @fn char[+] format( bool[+] A, int[2] w)
 *
 * @brief Defined-width format on boolean non-scalar.
 *
 ******************************************************************************/
DOINL
char[+] format( bool[+] A, int[2] w)
{
  res = format( tod( A), w);
  return( res);
}


/******************************************************************************
 *
 * @fn char[.] format( int A)
 *
 * @brief Default format on integer scalar.
 *
 ******************************************************************************/
DOINL
char[.] format( int A)
{
  res = tochar( sprintf( "%d", A));
  return( res);
}

/******************************************************************************
 *
 * @fn char[.] format( long A)
 *
 * @brief Default format on long scalar.
 *
 ******************************************************************************/
DOINL
char[.] format( long A)
{
  res = tochar( sprintf( "%ld", A));
  return( res);
}

/******************************************************************************
 *
 * @fn char[+] format( int[d:shp,n] A)
 *
 * @brief Default format on integer non-scalar.
 *
 * Refer to UTThorn.dws <thint> for APL model of this.
 *
 ******************************************************************************/
DOINL
char[+] format( int[d:shp,n] A)
{
  shpm = [prod( shp)] ++ [n];
  if (prod( shpm) == 0) {
    res = genarray(shp, ' ');
  } else {
    m = reshape( shpm, A);
    widths = pmtl( maxsl1( abs( m)));
    // Large negative number may need extra column for minus sign
    maxneg = minsl1( m);
    neg = toi( maxneg < 0);
    maxneg2 = pmtl( abs( maxneg));
    widths = widths + neg * toi( maxneg2 >= widths);
    zcols = sum( widths + 1) - 1;
    zdef = genarray( [zcols], ' ');

    res = with {
            ( . <= iv <= . )
              : formatrow( widths, m[ iv]);
          } : genarray( take( [1], shape( m)), zdef);

    shpz = shp ++ take( [-1], shape( res));
    res = reshape( shpz, res);
  }
  return( res);
}

/******************************************************************************
 *
 * @fn char[.] format( int A, int precision)
 *
 * @brief Defined-precision format on integer scalar.
 *
 ******************************************************************************/
DOINL
char[.] format( int A, int precision)
{
  res = format( tod( A), precision);
  return( res);
}

/******************************************************************************
 *
 * @fn char[+] format( int[+] A, int precision)
 *
 * @brief Precision-significant digit format on integer non-scalar.
 *
 ******************************************************************************/
DOINL
char[+] format( int[+] A, int precision)
{
  res = format( tod( A), precision);
  return( res);
}

/******************************************************************************
 *
 * @fn char[.] format( int A, int[2] w)
 *
 * @brief Defined-width and precision format on integer scalar.
 *
 * @param w[0] The maximum legal result width. If result is wider than this,
 *        the result will be filled with asterixs ('*').
 * @param w[1] The number of significant digits to be printed.
 *
 ******************************************************************************/
DOINL
char[.] format( int A, int[2] w)
{
  res = tochar( sprintf( "%*.*d", w[ 0], w[ 1], A));
  res = overflowCheck( res, w[ 0]);
  return( res);
}


/******************************************************************************
 *
 * @fn char[.] format( float A)
 *
 * @brief Default format on float scalar.
 *
 ******************************************************************************/
DOINL
char[.] format( float A)
{
  precision = 15;
  res = format( tod( A), precision);
  return( res);
}

/******************************************************************************
 *
 * @fn char[+] format( float[+] A)
 *
 * @brief Default format on float non-scalar.
 *
 ******************************************************************************/
DOINL
char[+] format( float[+] A)
{
  precision = 15;
  res = format( tod( A), precision);
  return( res);
}

/******************************************************************************
 *
 * @fn char[.] format( float A, int precision)
 *
 * @brief Defined-precision format on floating scalar.
 *
 ******************************************************************************/
DOINL
char[.] format( float A, int precision)
{
  res = format( tod( A), precision);
  return( res);
}

/******************************************************************************
 *
 * @fn char[+] format( float[+] A, int precision)
 *
 * @brief Precision-significant digit format on floating non-scalar.
 *
 ******************************************************************************/
DOINL
char[+] format( float[+] A, int precision)
{
  res = format( tod( A), precision);
  return( res);
}

/******************************************************************************
 *
 * @fn char[.] format( float A, int[2] w)
 *
 * @brief Defined-width and precision format on floating scalar.
 *
 * @param w[0] The maximum legal result width. If result is wider than this,
 *        the result will be filled with asterixs ('*').
 * @param w[1] The number of significant digits to be printed.
 *
 ******************************************************************************/
DOINL
char[.] format( float A, int[2] w)
{
  res = format( tod( A), w);
  return( res);
}

/******************************************************************************
 *
 * @fn char[+] format(float[+] A, int[2] w)
 *
 * @brief Defined-width format on float non-scalar.
 *
 * @param w[0] The maximum legal result width. If result is wider than this,
 *        the result will be filled with asterixs ('*').
 * @param w[1] The number of significant digits to be printed.
 *
 ******************************************************************************/
DOINL
char[+] format(float[+] A, int[2] w)
{
  res = format( tod( A), w);
  return( res);
}


/******************************************************************************
 *
 * @fn char[.] format( double A)
 *
 * @brief Default format on double scalar.
 *
 ******************************************************************************/
DOINL
char[.] format( double A)
{
  precision = 15;
  res = format( A, precision);
  return( res);
}

/******************************************************************************
 *
 * @fn char[+] format( double[+] A)
 *
 * @brief Default format on double non-scalar.
 *
 * Refer to UTThorn.dws <threal> for APL model of this.
 *
 ******************************************************************************/
DOINL
char[+] format( double[+] A)
{
  precision = 15;
  res = format( A, precision);
  return( res);
}

/******************************************************************************
 *
 * @fn char[.] format( double A, int precision)
 *
 * @brief Formatting for a double scalar.
 *
 ******************************************************************************/
DOINL
char[.] format( double A, int precision)
{
  res = scalarFormatter( A, precision);
  res = padWithBlanks( precision + 7, res);
  return( res);
}

/******************************************************************************
 *
 * @fn char[+] format( double[d:shp] A, int precision)
 *
 * @brief Precision-significant digit format on double non-scalar.
 *
 * @note Refer to UTThorn.dws <threal> for APL model of this.
 *
 ******************************************************************************/
DOINL
char[+] format( double[d:shp] A, int precision)
{
  rows = prod( drop( [-1], shp));
  cols = take( [-1], [1] ++ shp)[ 0];
  ravel = reshape( [prod( shp)], A);

  // Formatted results and their shapes
  // See scalarFormatter for why the value 7 appears in next line
  wid = precision + 7;
  defcell = genarray( [wid], ' ');

  // Format each array element
  fry = with {
          ( . <= iv <= . ) {
            el = scalarFormatter( ravel[ iv], precision);
            el = padWithBlanks( wid, el);
          } : el;
        } : genarray( shape( ravel), defcell);

  // Determine width of each result column
  // First, chars left of decimal point
  odpshp = [shape( fry)[ 0]];
  lodp = with {
          ( . <= iv <= . )
            : thCharsTo ([' ', '.'], fry[ iv]);
        } : genarray( odpshp, 0);
  // Decimal point and # non-blankchars to right of decimal point
  rodp = with {
          ( . <= iv <= . )
            : thCharsTo( [' ', ' '], drop( [lodp[ iv]], fry[ iv]));
        } : genarray( odpshp, 0);

  lodpmax = maxsl1( reshape( [rows, cols], lodp));
  rodpmax = maxsl1( reshape( [rows, cols], rodp));
  widths = lodpmax + rodpmax;
  zcols = sum( widths + 2) - 1;  // Room for decimal point and blank
  shpz = drop( [-1], shp) ++ [zcols];
  defcell = genarray( [zcols], ' ');

  res = with {
        ([0] <= [i] < [rows])
          : alignrow( fry, i, widths, lodp, lodpmax, zcols);
      } : genarray( [rows], defcell);
  res = reshape( shpz, res);
  return( res);
}

/******************************************************************************
 *
 * @fn char[.] format( double A, int[2] w)
 *
 * @brief Formatting for a double scalar.
 *
 * @note This is temporary, pending use of the Burger/Dybvig algorithm.
 *
 * @param w[0] The maximum legal result width. If result is wider than this,
 *        the result will be filled with asterixs ('*').
 * @param w[1] The number of significant digits to be printed.
 *
 ******************************************************************************/
DOINL
char[.] format( double A, int[2] w)
{
  res = tochar( sprintf( "%*.*g", w[ 0], w[ 1], A));
  res = overflowCheck( res, w[ 0]);
  return( res);
}

/******************************************************************************
 *
 * @fn char[+] format( double[d:shp] A, int[2] w)
 *
 * @brief Defined-width format on double non-scalar.
 *
 * @param w[0] The maximum legal result width. If result is wider than this,
 *        the result will be filled with asterixs ('*').
 * @param w[1] The number of significant digits to be printed.
 *
 ******************************************************************************/
DOINL
char[+] format( double[d:shp] A, int[2] w)
{
  defcell = genarray( [w[ 0]], ' ');
  res = with {
        ( . <= iv < . )
          : format( A[ iv], w);
      } : genarray( shp, defcell);
  zshp = shape( res);
  zshp = drop( [-2], zshp) ++ [prod( take( [-2], zshp))];
  res = reshape( zshp, res);
  return( res);
}


/******************************************************************************
 *
 * Private helper functions for formatting.
 *
 ******************************************************************************/

/******************************************************************************
 *
 * @fn char[olen] formatrow( int[vlen] wid, int[vlen] A)
 *
 * @brief Utility function for formatting an int vector to widths wid.
 *
 ******************************************************************************/
inline
char[olen] formatrow( int[vlen] wid, int[vlen] A)
{
  olen = sum( wid + 1) - 1;
  res = genarray( [olen], ' ');

  // Can't use WL because widths may differ
  sink = 0;
  for (i = 0; i < vlen; i++) {
    curm = A[ i];
    curw = wid[ i];
    curz = format( curm, [curw, 1]);
    lim  = shape( curz)[ 0];

    for (src = 0; src < lim; src++) {
      res = modarray( res, src + sink, curz[ src]);
    }

    // Inter-element blank
    sink = sink + 1 + wid[ i];
  }
  return( res);
}

/******************************************************************************
 *
 * @fn int[d:shp] pmtl( int[d:shp] A)
 *
 * @brief Poor man's 10-logarithm, used to compute column widths.
 *
 ******************************************************************************/
int[d:shp] pmtl( int[d:shp] A)
{
  // Avoid 10 log 0!
  res = toi( log10( tod( max( A, 2)))) + 1;
  return( res);
}

/******************************************************************************
 *
 * @fn int[n] maxsl1( int[n,m] A)
 *
 * @brief First-axis max-reduce rank-2 matrix.
 *
 ******************************************************************************/
inline
int[n] maxsl1( int[n,m] A)
{
  res = with {
          ([0] <= iv < [n]) : A[ iv];
        } : fold( max, minint());
  return( res);
}

/******************************************************************************
 *
 * @fn int[n] minsl1( int[n,m] A)
 *
 * @brief First-axis min-reduce rank-2 matrix.
 *
 ******************************************************************************/
inline
int[n] minsl1( int[n,m] A)
{
  res = with {
          ([0] <= iv < [n]) : A[ iv];
        } : fold( min, maxint());
  return( res);
}

/******************************************************************************
 *
 * @fn char[zcols] alignrow( char[.,.] fry, int i, int[cols] widths,
 *                           int[.] lodp, int[.] lodpmax, int zcols)
 *
 * @brief Align one row of a floating-point matrix.
 *
 ******************************************************************************/
char[zcols] alignrow( char[.,.] fry, int i, int[cols] widths,
                      int[.] lodp, int[.] lodpmax, int zcols)
{
  res = genarray( [zcols], ' ');
  zci = 0;
  for (ci = 0; ci < cols; ci++) {
    fi = ci + cols * i;             // Source item index
    sc = lodp[ fi] - lodpmax[ ci];  // Shift count to align decimal
    sefe = thCharsTo( [' ', ' '], fry[ fi]);
    sz = sefe + abs( sc);
    zit = padWithBlanks( sz, rotate( [-sc], fry[ fi]));
    res, junk = thrnAppend( res, zci, zit);
    zci = zci + widths[ ci] + 1;
  }
  return( res);
}

/******************************************************************************
 *
 * @fn char[wid] padWithBlanks( int wid, char[n] A)
 *
 * @brief SAC does not have overtake, so this does the job.
 *
 ******************************************************************************/
inline
char[wid] padWithBlanks( int wid, char[n] A)
{
  maxidx = max( wid, n);
  res = with {
          ([0] <= iv < [maxidx]) : A[ iv];
        } : genarray( [wid], ' ');
  return( res);
}

/******************************************************************************
 *
 * @fn int thCharsTo( char[n] ch, char[lim] fry)
 *
 * @brief Find chars left of decimal point (or end).
 *        I.e., (fry member ch) iota 1.
 *
 ******************************************************************************/
inline
int thCharsTo( char[n] ch, char[lim] fry)
  | n > 1
{
  res = lim;
  for (i = 0; i < lim; i++) {
    if (fry[ i] == ch[ 0] || fry[ i] == ch[ 1]) {
      res = i;
      i = lim;
    }
  }
  return( res);
}

/******************************************************************************
 *
 * @fn char[d], int thrnAppend( char[d] vec, int sink, char[n] A)
 *
 * @brief Indexed assign array into vec for next result element.
 *
 ******************************************************************************/
inline
char[d], int thrnAppend( char[d] vec, int sink, char[n] A)
{
  res = vec;
  for (src = 0; src < n; src++) {
    res[ sink] = A[ src];
    sink++;
  }
  return( res, sink);
}

/******************************************************************************
 *
 * @fn char[.] scalarFormatter( double A, int precision)
 *
 * @brief Primitive double scalar formatter, because sprintf gives wrong answers.
 *
 * @todo Write proper formatter, using Steele/Burger formatting.
 *
 ******************************************************************************/
char[.] scalarFormatter( double A, int precision)
{
  res = tochar( sprintf( "%.*g", precision, A));
  res = killPlusSign( res);
  return( res);
}

/******************************************************************************
 *
 * @fn char[.] killPlusSign( char[n] A)
 *
 * @brief Kill "+" in sprintf result for a formatted scalar.
 *        This is "(A != '+') compress A", the hard way
 *
 ******************************************************************************/
inline
char[.] killPlusSign( char[n] A)
{
  res = A;
  sink = 1;
  for (src = 1; src < n; src++) {
    res[ sink] = A[ src];
    if (res[ sink] != '+') {
      sink++;
    }
  }
  res = take( [sink], res);
  return( res);
}

/******************************************************************************
 *
 * @fn char[.] overflowCheck( char[n] A, int wid)
 *
 * @brief Check for txt overflowing wid.
 *
 ******************************************************************************/
inline
char[.] overflowCheck( char[n] A, int wid)
{
  res = wid < n ? genarray( [wid], '*') : A;
  return( res);
}
