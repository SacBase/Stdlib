module ArrayFormat;

use Array: all;
use String: { tochar, sprintf };

export { format };

#include "Templates.mac"

// This is a crude workaround for issue #2333, which Bodo
// suggests requires major redesign of modules.
#define DOINL inline

/******************************************************************************
 *
 * APL Array formatting functions.
 *
 * These functions generate character representations of SAC arrays for
 * APL-based code. The functions come in several classes:
 *   - Default formatting: array elements are formatted to the minimum width
 *     that does not lose precision.
 *   - Defined formatting to specified precision, p: array elements are
 *     formatted to p significant digits.
 *   - Defined formatting: array elements are formatted to specified
 *     precision and width. If a result element does not fit within width,
 *     that element is replaced by '*'.
 *
 ******************************************************************************/

/******************************************************************************
 *
 * @fn char[d:shp] format( char[d:shp] A)
 *
 * @brief Default format for any character array.
 *
 ******************************************************************************/
DOINL
char[d:shp] format( char[d:shp] A)
{
  return A;
}


/******************************************************************************
 *
 * @fn char[1] format( bool A)
 *
 * @brief Default format for boolean scalar.
 *
 ******************************************************************************/
DOINL
char[1] format( bool A)
{
  return [A ? '1' : '0'];
}

/******************************************************************************
 *
 * @fn char[+] format( bool[d:shp,n] A)
 *
 * Default format for boolean non-scalars.
 *
 ******************************************************************************/
DOINL
char[d:shp,m] format( bool[d:shp,n] A)
  | m == max( 2 * n - 1, 0)
{
  res = { iv -> A[ iv] ? ['1', ' '] : ['0', ' '] };
  res = reshape( shp ++ [2 * n], res);
  lastcol = genarray( [d], 0) ++ [-1];
  res = drop( lastcol, res);
  return res;
}

/******************************************************************************
 *
 * @fn char[.] format( bool A, int[2] w)
 *
 * @brief Defined-width and precision format on boolean scalar.
 *
 * @param w[0] The maximum legal result width. If result is wider than this,
 *        the result will be filled with asterixs ('*').
 * @param w[1] The number of significant digits to be printed.
 *
 ******************************************************************************/
DOINL
char[.] format( bool A, int[2] w)
{
  return format( tod( A), w);
}

/******************************************************************************
 *
 * @fn char[+] format( bool[+] A, int[2] w)
 *
 * @brief Defined-width format on boolean non-scalar.
 *
 ******************************************************************************/
DOINL
char[d:shp,m] format( bool[d:shp,n] A, int[2] w)
  | m == max( 2 * n - 1, 0)
{
  return format( tod( A), w);
}


/******************************************************************************
 *
 * @fn char[.] format( int A)
 *
 * @brief Default format on integer scalar.
 *
 ******************************************************************************/
DOINL
char[.] format( int A)
{
  return tochar( sprintf( "%d", A));
}

/******************************************************************************
 *
 * @fn char[.] format( long A)
 *
 * @brief Default format on long scalar.
 *
 ******************************************************************************/
DOINL
char[.] format( long A)
{
  return tochar( sprintf( "%ld", A));
}

/******************************************************************************
 *
 * @fn char[+] format( int[d:shp,n] A)
 *
 * @brief Default format on integer non-scalar.
 *
 * Refer to UTThorn.dws <thint> for APL model of this.
 *
 ******************************************************************************/
DOINL
char[+] format( int[d:shp,n] A)
{
  shpp = prod( shp);
  if (shpp == 0 || n == 0) {
    res = genarray( shp, ' ');
  } else {
    m = reshape( [shpp, n], A);

    // Large negative number may need extra column for minus sign
    minm = minsl1( m);
    maxneg = log10( abs( minm));
    widths = log10( maxsl1( abs( m)));
    widths += toi( minm < 0) * toi( maxneg >= widths);
    zcols = sum( widths + 1) - 1;

    res = { [i] -> formatrow( widths, m[ i]) | [i] < [shpp] };
    res = reshape( shp ++ [zcols], res);
  }

  return res;
}

/******************************************************************************
 *
 * @fn char[.] format( int A, int precision)
 *
 * @brief Defined-precision format on integer scalar.
 *
 ******************************************************************************/
DOINL
char[.] format( int A, int precision)
{
  return format( tod( A), precision);
}

/******************************************************************************
 *
 * @fn char[+] format( int[+] A, int precision)
 *
 * @brief Precision-significant digit format on integer non-scalar.
 *
 ******************************************************************************/
DOINL
char[+] format( int[+] A, int precision)
{
  return format( tod( A), precision);
}

/******************************************************************************
 *
 * @fn char[.] format( int A, int[2] w)
 *
 * @brief Defined-width and precision format on integer scalar.
 *
 * @param w[0] The maximum legal result width. If result is wider than this,
 *        the result will be filled with asterixs ('*').
 * @param w[1] The number of significant digits to be printed.
 *
 ******************************************************************************/
DOINL
char[.] format( int A, int[2] w)
{
  res = tochar( sprintf( "%*.*d", w[ 0], w[ 1], A));
  res = overflowCheck( res, w[ 0]);
  return res;
}


/******************************************************************************
 *
 * @fn char[.] format( float A)
 *
 * @brief Default format on float scalar.
 *
 ******************************************************************************/
DOINL
char[.] format( float A)
{
  return format( tod( A), 15);
}

/******************************************************************************
 *
 * @fn char[+] format( float[+] A)
 *
 * @brief Default format on float non-scalar.
 *
 ******************************************************************************/
DOINL
char[+] format( float[+] A)
{
  return format( tod( A), 15);
}

/******************************************************************************
 *
 * @fn char[.] format( float A, int precision)
 *
 * @brief Defined-precision format on floating scalar.
 *
 ******************************************************************************/
DOINL
char[.] format( float A, int precision)
{
  return format( tod( A), precision);
}

/******************************************************************************
 *
 * @fn char[+] format( float[+] A, int precision)
 *
 * @brief Precision-significant digit format on floating non-scalar.
 *
 ******************************************************************************/
DOINL
char[+] format( float[+] A, int precision)
{
  return format( tod( A), precision);
}

/******************************************************************************
 *
 * @fn char[.] format( float A, int[2] w)
 *
 * @brief Defined-width and precision format on floating scalar.
 *
 * @param w[0] The maximum legal result width. If result is wider than this,
 *        the result will be filled with asterixs ('*').
 * @param w[1] The number of significant digits to be printed.
 *
 ******************************************************************************/
DOINL
char[.] format( float A, int[2] w)
{
  return format( tod( A), w);
}

/******************************************************************************
 *
 * @fn char[+] format(float[+] A, int[2] w)
 *
 * @brief Defined-width format on float non-scalar.
 *
 * @param w[0] The maximum legal result width. If result is wider than this,
 *        the result will be filled with asterixs ('*').
 * @param w[1] The number of significant digits to be printed.
 *
 ******************************************************************************/
DOINL
char[+] format(float[+] A, int[2] w)
{
  return format( tod( A), w);
}


/******************************************************************************
 *
 * @fn char[.] format( double A)
 *
 * @brief Default format on double scalar.
 *
 ******************************************************************************/
DOINL
char[.] format( double A)
{
  return format( A, 15);
}

/******************************************************************************
 *
 * @fn char[+] format( double[+] A)
 *
 * @brief Default format on double non-scalar.
 *
 * Refer to UTThorn.dws <threal> for APL model of this.
 *
 ******************************************************************************/
DOINL
char[+] format( double[+] A)
{
  return format( A, 15);
}

/******************************************************************************
 *
 * @fn char[.] format( double A, int precision)
 *
 * @brief Formatting for a double scalar.
 *
 ******************************************************************************/
DOINL
char[.] format( double A, int precision)
{
  res = scalarFormatter( A, precision);
  res = padWithBlanks( precision + 7, res);
  return res;
}

/******************************************************************************
 *
 * @fn char[+] format( double[d:shp] A, int precision)
 *
 * @brief Precision-significant digit format on double non-scalar.
 *
 * @note Refer to UTThorn.dws <threal> for APL model of this.
 *
 ******************************************************************************/
DOINL
char[+] format( double[d:shp,n] A, int precision)
{
  shpp = prod( shp);
  if (shpp == 0 || n == 0) {
    res = genarray( shp, ' ');
  } else {
    ravel = reshape( [shpp * n], A);

    // Format each array element
    // See scalarFormatter for why we do 'precision + 7'
    fry = { [i] -> padWithBlanks( precision + 7,
                                  scalarFormatter( ravel[ i], precision)) };

    // Determine width of each result column
    // First, chars left of decimal point
    lodp = { [i] -> thCharsTo( [' ', '.'], fry[ i]) };
    // Decimal point and # non-blankchars to right of decimal point
    rodp = { [i] -> thCharsTo( [' ', ' '], drop( [lodp[ i]], fry[ i])) };

    lodpmax = maxsl1( reshape( [shpp, n], lodp));
    rodpmax = maxsl1( reshape( [shpp, n], rodp));
    widths = lodpmax + rodpmax;
    zcols = sum( widths + 2) - 1;  // Room for decimal point and blank

    res = { [i] -> alignrow( fry, i, widths, lodp, lodpmax, zcols)
          | [i] < [shpp] };
    res = reshape( shp ++ [zcols], res);
  }

  return res;
}

/******************************************************************************
 *
 * @fn char[.] format( double A, int[2] w)
 *
 * @brief Formatting for a double scalar.
 *
 * @note This is temporary, pending use of the Burger/Dybvig algorithm.
 *
 * @param w[0] The maximum legal result width. If result is wider than this,
 *        the result will be filled with asterixs ('*').
 * @param w[1] The number of significant digits to be printed.
 *
 ******************************************************************************/
DOINL
char[.] format( double A, int[2] w)
{
  res = tochar( sprintf( "%*.*g", w[ 0], w[ 1], A));
  res = overflowCheck( res, w[ 0]);
  return res;
}

/******************************************************************************
 *
 * @fn char[+] format( double[d:shp] A, int[2] w)
 *
 * @brief Defined-width format on double non-scalar.
 *
 * @param w[0] The maximum legal result width. If result is wider than this,
 *        the result will be filled with asterixs ('*').
 * @param w[1] The number of significant digits to be printed.
 *
 ******************************************************************************/
DOINL
char[+] format( double[d:shp] A, int[2] w)
{
  res = { iv -> format( A[ iv], w) | iv < shp };
  zshp = shape( res);
  zshp = drop( [-2], zshp) ++ [prod( take( [-2], zshp))];
  res = reshape( zshp, res);
  return res;
}


/******************************************************************************
 *
 * Private helper functions for formatting.
 *
 ******************************************************************************/

/******************************************************************************
 *
 * @fn char[olen] formatrow( int[vlen] wid, int[vlen] A)
 *
 * @brief Utility function for formatting an int vector to widths wid.
 *
 ******************************************************************************/
inline
char[olen] formatrow( int[vlen] wid, int[vlen] A)
{
  olen = sum( wid + 1) - 1;
  res = genarray( [olen], ' ');

  // Can't use WL because widths may differ
  sink = 0;
  for (i = 0; i < vlen; i++) {
    w = [wid[ i], 1];
    curz = format( A[ i], w);
    lim  = shape( curz)[ 0];

    for (src = 0; src < lim; src++) {
      res = modarray( res, src + sink, curz[ src]);
    }

    // Inter-element blank
    sink += wid[ i] + 1;
  }

  return res;
}

/******************************************************************************
 *
 * @fn int[d:shp] log10( int[d:shp] A)
 *
 * @brief Poor man's 10-logarithm, used to compute column widths.
 *
 ******************************************************************************/
int[d:shp] log10( int[d:shp] A)
{
  // Avoid 10 log 0!
  return toi( MathArray::log10( tod( max( A, 2)))) + 1;
}

/******************************************************************************
 *
 * @fn int[n] maxsl1( int[n,m] A)
 *
 * @brief First-axis max-reduce rank-2 matrix.
 *
 ******************************************************************************/
inline
int[n] maxsl1( int[n,m] A)
{
  res = with {
          ([0] <= iv < [n]) : A[ iv];
        } : fold( max, minint());
  return res;
}

/******************************************************************************
 *
 * @fn int[n] minsl1( int[n,m] A)
 *
 * @brief First-axis min-reduce rank-2 matrix.
 *
 ******************************************************************************/
inline
int[n] minsl1( int[n,m] A)
{
  res = with {
          ([0] <= iv < [n]) : A[ iv];
        } : fold( min, maxint());
  return res;
}

/******************************************************************************
 *
 * @fn char[zcols] alignrow( char[.,.] fry, int i, int[cols] widths,
 *                           int[.] lodp, int[.] lodpmax, int zcols)
 *
 * @brief Align one row of a floating-point matrix.
 *
 ******************************************************************************/
char[zcols] alignrow( char[.,.] fry, int i, int[cols] widths,
                      int[.] lodp, int[.] lodpmax, int zcols)
{
  res = genarray( [zcols], ' ');

  zci = 0;
  for (ci = 0; ci < cols; ci++) {
    fi = ci + cols * i;             // Source item index
    sc = lodp[ fi] - lodpmax[ ci];  // Shift count to align decimal
    sefe = thCharsTo( [' ', ' '], fry[ fi]);
    sz = sefe + abs( sc);
    zit = padWithBlanks( sz, rotate( [-sc], fry[ fi]));
    res, junk = thrnAppend( res, zci, zit);
    zci += widths[ ci] + 1;
  }

  return res;
}

/******************************************************************************
 *
 * @fn char[wid] padWithBlanks( int wid, char[n] A)
 *
 * @brief SAC does not have overtake, so this does the job.
 *
 ******************************************************************************/
inline
char[wid] padWithBlanks( int wid, char[n] A)
{
  maxidx = max( wid, n);
  res = with {
          ([0] <= iv < [maxidx]) : A[ iv];
        } : genarray( [wid], ' ');
  return res;
}

/******************************************************************************
 *
 * @fn int thCharsTo( char[n] ch, char[lim] fry)
 *
 * @brief Find chars left of decimal point (or end).
 *        I.e., (fry member ch) iota 1.
 *
 ******************************************************************************/
inline
int thCharsTo( char[n] ch, char[lim] fry)
  | n > 1
{
  res = lim;
  for (i = 0; i < lim; i++) {
    if (fry[ i] == ch[ 0] || fry[ i] == ch[ 1]) {
      res = i;
      i = lim;
    }
  }

  return res;
}

/******************************************************************************
 *
 * @fn char[d], int thrnAppend( char[d] vec, int sink, char[n] A)
 *
 * @brief Indexed assign array into vec for next result element.
 *
 ******************************************************************************/
inline
char[d], int thrnAppend( char[d] vec, int sink, char[n] A)
{
  res = vec;
  for (src = 0; src < n; src++) {
    res[ sink] = A[ src];
    sink++;
  }

  return (res, sink);
}

/******************************************************************************
 *
 * @fn char[.] scalarFormatter( double A, int precision)
 *
 * @brief Primitive double scalar formatter, because sprintf gives wrong answers.
 *
 * @todo Write proper formatter, using Steele/Burger formatting.
 *
 ******************************************************************************/
char[.] scalarFormatter( double A, int precision)
{
  res = tochar( sprintf( "%.*g", precision, A));
  res = killPlusSign( res);
  return res;
}

/******************************************************************************
 *
 * @fn char[.] killPlusSign( char[n] A)
 *
 * @brief Kill "+" in sprintf result for a formatted scalar.
 *        This is "(A != '+') compress A", the hard way
 *
 ******************************************************************************/
inline
char[.] killPlusSign( char[n] A)
{
  res = A;
  sink = 1;
  for (src = 1; src < n; src++) {
    res[ sink] = A[ src];
    sink += toi( res[ sink] != '+');
  }

  res = take( [sink], res);
  return res;
}

/******************************************************************************
 *
 * @fn char[.] overflowCheck( char[n] A, int wid)
 *
 * @brief Check for txt overflowing wid.
 *
 ******************************************************************************/
inline
char[.] overflowCheck( char[n] A, int wid)
{
  return wid < n ? genarray( [wid], '*') : A;
}
