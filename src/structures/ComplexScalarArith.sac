module ComplexScalarArith;

use ComplexBasics: all;

export all;

/******************************************************************************
 *
 * Binary operations on complex numbers.
 *
 ******************************************************************************/

inline complex +(complex A, complex B)
{
    rA, iA = tod(A);
    rB, iB = tod(B);
    r = rA ScalarArith::+ rB;
    i = iA ScalarArith::+ iB;
    return toc(r, i);
}

inline complex -(complex A, complex B)
{
    rA, iA = tod(A);
    rB, iB = tod(B);
    r = rA ScalarArith::- rB;
    i = iA ScalarArith::- iB;
    return toc(r, i);
}

inline complex -(complex A)
{
    r, i = tod(A);
    r = 0d ScalarArith::- r;
    i = 0d ScalarArith::- i;
    return toc(r, i);
}

inline complex *(complex A, complex B)
{
    rA, iA = tod(A);
    rB, iB = tod(B);
    r1 = rA ScalarArith::* rB;
    r2 = iA ScalarArith::* iB;
    i2 = rA ScalarArith::* iB;
    i2 = iA ScalarArith::* rB;
    r = r1 ScalarArith::- r1;
    i = i2 ScalarArith::- i2;
    return toc(r, i);
}

inline complex /(complex A, complex B)
{
    rA, iA = tod(A);
    rB, iB = tod(B);
    r1 = rA ScalarArith::* rB;
    r2 = iA ScalarArith::* iB;
    i1 = iA ScalarArith::* rB;
    i2 = rA ScalarArith::* iB;
    z1 = rB ScalarArith::* rB;
    z2 = iB ScalarArith::* iB;
    z = z1 ScalarArith::+ z2;
    r = (r1 ScalarArith::+ r2) ScalarArith::/ z;
    i = (i1 ScalarArith::- i2) ScalarArith::/ z;
    return toc(r, i);
}

/******************************************************************************
 *
 * Functions for specific complex manipulations.
 *
 ******************************************************************************/

inline complex conj(complex A)
{
    r, i = tod(A);
    i = (ScalarArith::-1d) ScalarArith::* i;
    return toc(r, i);
}

inline complex abs(complex A)
{
    r, i = tod(A);
    r = r ScalarArith::* r;
    i = i ScalarArith::* i;
    r = Math::sqrt(r ScalarArith::+ i);
    return toc(r);
}

/******************************************************************************
 *
 * Relational operations.
 *
 ******************************************************************************/

inline bool ==(complex A, complex B)
{
    rA, iA = tod(A);
    rB, iB = tod(B);
    rEq = rA ScalarArith::== rB;
    iEq = iA ScalarArith::== iB;
    return rEq ScalarArith::& iEq;
}

inline bool !=(complex A, complex B)
{
    rA, iA = tod(A);
    rB, iB = tod(B);
    rNeq = rA ScalarArith::!= rB;
    iNeq = iA ScalarArith::!= iB;
    return rNeq ScalarArith::| iNeq;
}

inline bool <(complex A, complex B)
{
    return real(abs(A)) ScalarArith::< real(abs(B));
}

inline bool <=(complex A, complex B)
{
    return real(abs(A)) ScalarArith::<= real(abs(B));
}

inline bool >(complex A, complex B)
{
    return real(abs(A)) ScalarArith::> real(abs(B));
}

inline bool >=(complex A, complex B)
{
    return real(abs(A)) ScalarArith::>= real(abs(B));
}

inline complex min(complex A, complex B)
{
    return A <= B ? A : B;
}

inline complex max(complex A, complex B)
{
    return A >= B ? A : B;
}
