module Grey;

#define OVERLOAD dim,shape,sel,reshape,tod,toi,+,-
use Array: all except { OVERLOAD };
import Array: { OVERLOAD };

export all;

typedef int grey;

/******************************************************************************
 *
 * Array properties.
 *
 * @note `dim` and `shape` may not use type patterns, as type patterns rely
 * on the existence of those functions for typedefs.
 *
 ******************************************************************************/

inline int dim(grey[*] arr)
{
    return dim((int[*])arr);
}

inline int[.] shape(grey[*] arr)
{
    return shape((int[*])arr);
}

inline grey[i:ishp] sel(int[o] idx, grey[o:oshp,i:ishp] arr)
    | all(0 <= idx), all(idx < oshp)
{
    return (grey[*])((int[*])arr)[idx];
}

inline grey[d:shp] reshape(int[d] shp, grey[_:shp_a] arr)
    | prod(shp) == prod(shp_a)
{
    return (grey[*])_reshape_VxA_(shp, (int[*])arr);
}

/******************************************************************************
 *
 * Type conversions.
 *
 ******************************************************************************/

inline grey tog(int g)
{
    return (grey)max(min(g, 255), 0);
}

inline grey tog(double g)
{
    return (grey)max(min(toi(g), 255), 0);
}

inline int[*] toi(grey g)
{
    return (int[*])g;
}

inline double[*] tod(grey g)
{
    return tod((int[*]) g);
}

/******************************************************************************
 *
 * Binary operations.
 *
 ******************************************************************************/

inline grey +(grey g1, grey g2)
{
    return tog(toi(g1) + toi(g2));
}

inline grey -(grey g1, grey g2)
{
    return tog(toi(g1) - toi(g2));
}
