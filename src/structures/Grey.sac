module Grey;

use Array: { all, <, <=, == };

export all;

typedef int grey;

/******************************************************************************
 *
 * Array properties.
 *
 * @note The definition of `dim` and `shape` for user-defined types may not use
 * type patterns, as type patterns rely on the existence of these functions
 * for user-defined types since the primitives `_dim_A_` and `_shape_A_`
 * are not defined for user-defined types.
 *
 ******************************************************************************/

inline int dim(grey[*] arr)
{
    return Array::dim((int[*])arr);
}

inline int[.] shape(grey[*] arr)
{
    return Array::shape((int[*])arr);
}

inline grey[i:ishp] sel(int[o] idx, grey[o:oshp,i:ishp] arr)
    | all(0 <= idx), all(idx < oshp)
{
    return (grey[*])Array::sel(idx, (int[*])arr);
}

inline grey[d:shp] reshape(int[d] shp, grey[_:shp_a] arr)
    | Array::prod(shp) == Array::prod(shp_a)
{
    return (grey[*])Array::reshape(shp, (int[*])arr);
}

/******************************************************************************
 *
 * Type conversions.
 *
 ******************************************************************************/

inline grey tog(int g)
{
    return (grey)Array::max(Array::min(g, 255), 0);
}

inline grey tog(double g)
{
    return (grey)Array::max(Array::min(Array::toi(g), 255), 0);
}

inline int toi(grey g)
{
    return (int)g;
}

inline double tod(grey g)
{
    return Array::tod((int)g);
}

/******************************************************************************
 *
 * Binary operations.
 *
 ******************************************************************************/

inline grey +(grey g1, grey g2)
{
    return tog(toi(g1) Array::+ toi(g2));
}

inline grey -(grey g1, grey g2)
{
    return tog(toi(g1) Array::- toi(g2));
}
