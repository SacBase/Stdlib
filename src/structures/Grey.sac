module Grey;

use Array: all except { dim,shape,sel,reshape,tod,toi,+,- };

export all;

typedef int grey;

/******************************************************************************
 *
 * Array properties.
 *
 * @note `dim` and `shape` may not use type patterns, as type patterns rely
 * on the existence of those functions for typedefs.
 *
 ******************************************************************************/

inline int dim(grey[*] arr)
{
    return Array::dim((int[*])arr);
}

inline int[.] shape(grey[*] arr)
{
    return Array::shape((int[*])arr);
}

inline grey[i:ishp] sel(int[o] idx, grey[o:oshp,i:ishp] arr)
    | all(0 <= idx), all(idx < oshp)
{
    return (grey[*])Array::sel(idx, (int[*])arr);
}

inline grey[d:shp] reshape(int[d] shp, grey[_:shp_a] arr)
    | prod(shp) == prod(shp_a)
{
    return (grey[*])Array::reshape(shp, (int[*])arr);
}

/******************************************************************************
 *
 * Type conversions.
 *
 ******************************************************************************/

inline grey tog(int g)
{
    return (grey)max(min(g, 255), 0);
}

inline grey tog(double g)
{
    return (grey)max(min(Array::toi(g), 255), 0);
}

inline int toi(grey g)
{
    return (int)g;
}

inline double tod(grey g)
{
    return Array::tod((int)g);
}

/******************************************************************************
 *
 * Binary operations.
 *
 ******************************************************************************/

inline grey +(grey g1, grey g2)
{
    return tog(toi(g1) Array::+ toi(g2));
}

inline grey -(grey g1, grey g2)
{
    return tog(toi(g1) Array::- toi(g2));
}
