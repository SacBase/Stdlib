module Color8;

use Array: { all, <, <=, == };
use MathArray: { exp, log };

export all except { Weights2Clut, genSteps };

typedef int[3] color;

/******************************************************************************
 *
 * Array properties.
 *
 * @note The definition of `dim` and `shape` for user-defined types may not use
 * type patterns, as type patterns rely on the existence of these functions
 * for user-defined types since the primitives `_dim_A_` and `_shape_A_`
 * are not defined for user-defined types.
 *
 ******************************************************************************/

inline int dim(color[*] arr)
{
    return Array::dim((int[*])arr) Array::- 1;
}

inline int[.] shape(color[*] arr)
{
    return Array::drop([Array::-1], Array::shape((int[*])arr));
}

inline color[i:ishp] sel(int[o] idx, color[o:oshp,i:ishp] arr)
    | all(0 <= idx), all(idx < oshp)
{
    return (color[*])Array::sel(idx, (int[*])arr);
}

inline color[d:shp] sel(int idx, color[n,d:shp] arr)
    | (0 <= idx), (idx < n)
{
    return arr[[idx]];
}

inline
color[d:shp] reshape(int[d] shp, color[_:shp_a] arr)
    | Array::prod(shp) == Array::prod(shp_a)
{
    return (color[*])Array::reshape(shp Array::++ [3], (int[*])arr);
}

/******************************************************************************
 *
 * Type conversions.
 *
 ******************************************************************************/

inline color newColor(int[3] c)
{
    min_col = [0, 0, 0];
    max_col = [255, 255, 255];
    c = Array::max(Array::min(c, max_col), min_col);
    return (color)c;
}

inline color newColor(int r, int g, int b)
{
    return newColor([r,g,b]);
}

inline int[3] toi(color c)
{
    return (int[3])c;
}

inline int[d:shp,3] toi(color[d:shp] c)
{
    return (int[*])c;
}

inline double[3] tod(color c)
{
    return Array::tod((int[3])c);
}

inline double[d:shp,3] tod(color[d:shp] c)
{
    return Array::tod((int[*])c);
}

inline int red(color c)
{
    return Array::sel([0], (int[3])c);
}

inline int green(color c)
{
    return Array::sel([1], (int[3])c);
}

inline int blue(color c)
{
    return Array::sel([2], (int[3])c);
}

inline int, int, int rgb(color c)
{
    return (red(c), green(c), blue(c));
}

/******************************************************************************
 *
 * Color operations.
 *
 ******************************************************************************/

inline color[256] Weights2Clut(double[256] w, color c1, color c2)
{
    w1 = { iv -> Array::sel(iv, w) Array::* tod(c1) | iv < [256] };
    w2 = { iv -> (1d Array::- Array::sel(iv, w)) Array::* tod(c2) | iv < [256] };
    return (color[256])Array::toi(w1 Array::+ w2);
}

inline double[256] genSteps(double from, double to)
{
    return from Array::+ Array::tod(Array::iota(256)) Array::/ 256d Array::* (to Array::- from);
}

inline color[256] genLinearClut(color c1, color c2)
{
    weights = genSteps(0d, 1d);
    return Weights2Clut(weights, c1, c2);
}

inline color[256] genLogarithmicClut(double from, double to, color c1, color c2)
{
    steps = genSteps(from, to);
    weights = (log(steps) Array::- log(from)) Array::/ (log(to) Array::- log(from));
    return Weights2Clut(weights, c1, c2);
}

inline color[256] genExponentialClut(double from, double to, color c1, color c2)
{
    steps = genSteps(from, to);
    weights = (exp(steps) Array::- exp(from)) Array::/ (exp(to) Array::- exp(from));
    return Weights2Clut(weights, c1, c2);
}

inline color[256] genAlternatingClut(color c1, color c2)
{
    return with {
        ( . <= [i] <= . step [2]) : c1;
    } : genarray([256], c2);
}

/*
 * h_in is the hue in degrees [0:360]
 * s_in is the saturation in % [0:100]
 * b_in is the brightness in % [0:100]
 */
inline color Hsb2Rgb(int h_in, int s_in, int b_in)
{
    c = black();

    if (b_in == 0)
        c = black();
    else if (b_in == 100 && s_in == 0)
        c = white();
    else if (s_in == 0)
        c = newColor(b_in, b_in, b_in);
    else
    {
        h = Array::tod(h_in) Array::/ 60d;
        s = Array::tod(s_in) Array::/ 100d;
        b = Array::tod(b_in) Array::/ 100d;

        i = Array::toi(h) Array::% 6;
        f = h Array::- Array::tod(i);

        if ((i Array::% 2) == 0) {
            f = 1d Array::- f;
        }

        m = b Array::* (1d Array::- s);
        n = b Array::* (1d Array::- s Array::* f);

        b = Array::toi(b Array::* 255d);
        m = Array::toi(m Array::* 255d);
        n = Array::toi(n Array::* 255d);

        if (0 == i)
            c = newColor(b, n, m);
        else if (1 == i)
            c = newColor(n, b, m);
        else if (2 == i)
            c = newColor(m, b, n);
        else if (3 == i)
            c = newColor(m, n, b);
        else if (4 == i)
            c = newColor(n, m, b);
        else if (5 == i)
            c = newColor(b, m, n);
    }

    return c;
}

inline color[d:shp] Hsb2Rgb(int[d:shp] h, int s, int b)
{
    return { iv -> Hsb2Rgb(Array::sel(iv, h), s, b) | iv < shp };
}

inline color[d:shp] Hsb2Rgb(int[d:shp] h, int[d:shp] s, int[d:shp] b)
{
    return { iv -> Hsb2Rgb(Array::sel(iv, h), Array::sel(iv, s), Array::sel(iv, b)) | iv < shp };
}

/******************************************************************************
 *
 * Binary operations.
 *
 ******************************************************************************/

inline color +(color a, color b)
{
    r1, g1, b1 = rgb(a);
    r2, g2, b2 = rgb(b);
    return newColor(r1 Array::+ r2, g1 Array::+ g2, b1 Array::+ b2);
}

inline color[d:shp] + (color[d:shp] a, color[d:shp] b)
{
    return { iv -> a[iv] + b[iv] | iv < shp };
}

inline color -(color a, color b)
{
    r1, g1, b1 = rgb(a);
    r2, g2, b2 = rgb(b);
    return newColor(r1 Array::- r2, g1 Array::- g2, b1 Array::- b2);
}

inline color[d:shp] -(color[d:shp] a, color[d:shp] b)
{
    return { iv -> a[iv] - b[iv] | iv < shp };
}

inline color *(color c, double x)
{
    r, g, b = rgb(c);
    return newColor(
        Array::toi(Array::tod(r) Array::* x),
        Array::toi(Array::tod(b) Array::* x),
        Array::toi(Array::tod(b) Array::* x)
    );
}

inline color[d:shp] *(color[d:shp] c, double x)
{
    return { iv -> c[iv] * x | iv < shp };
}

/******************************************************************************
 *
 * Color constants.
 *
 ******************************************************************************/

inline color black()
{
    return (color)[0,0,0];
}

inline color white()
{
    return (color)[255,255,255];
}

inline color red()
{
    return (color)[255,0,0];
}

inline color green()
{
    return (color)[0,255,0];
}

inline color blue()
{
    return (color)[0,0,255];
}
