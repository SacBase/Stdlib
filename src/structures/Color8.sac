module Color8;

#define OVERLOAD dim,shape,sel,reshape,tod,toi,+,-,*
use Array: all except { OVERLOAD };
import Array: { OVERLOAD };
use MathArray: all;

export all except { Weights2Clut, genSteps };

typedef int[3] color;

/******************************************************************************
 *
 * Array properties.
 *
 * @note `dim` and `shape` may not use type patterns, as type patterns rely
 * on the existence of these functions.
 *
 ******************************************************************************/

inline int dim(color[*] arr)
{
    return dim((int[*])arr) - 1;
}

inline int[.] shape(color[*] arr)
{
    return drop(-1, shape((int[*])arr));
}

inline color[i:ishp] sel(int[o] idx, color[o:oshp,i:ishp] arr)
    | all(0 <= idx), all(idx < oshp)
{
    return (color[*])((int[*])arr)[idx];
}

inline color[d:shp] sel(int idx, color[n,d:shp] arr)
    | (idx >= 0), (idx < n)
{
    return arr[[idx]];
}

inline
color[d:shp] reshape(int[d] shp, color[_:shp_a] arr)
    | prod(shp) == prod(shp_a)
{
    return (color[*])reshape(shp ++ [3], (int[*])arr);
}

/******************************************************************************
 *
 * Type conversions.
 *
 ******************************************************************************/

inline color newColor(int[3] c)
{
    min_col = [0, 0, 0];
    max_col = [255, 255, 255];
    c = max(min(c, max_col), min_col);
    return (color)c;
}

inline color newColor(int r, int g, int b)
{
    return newColor([r,g,b]);
}

inline int[3] toi(color c)
{
    return (int[3])c;
}

inline int[d:shp,3] toi(color[d:shp] c)
{
    return (int[*])c;
}

inline double[3] tod(color c)
{
    return tod((int[3])c);
}

inline double[d:shp,3] tod(color[d:shp] c)
{
    return tod((int[*])c);
}

inline int red(color c)
{
    return ((int[3])c)[0];
}

inline int green(color c)
{
    return ((int[3])c)[1];
}

inline int blue(color c)
{
    return ((int[3])c)[2];
}

inline int, int, int rgb(color c)
{
    return (red(c), green(c), blue(c));
}

/******************************************************************************
 *
 * Color operations.
 *
 ******************************************************************************/

inline color[256] Weights2Clut(double[256] w, color c1, color c2)
{
    return (color[256])toi({ iv -> w[iv] * tod(c1) }
                           + { iv -> (1d - w[iv]) * tod(c2) });
}

inline double[256] genSteps(double from, double to)
{
    return from + tod(iota(256)) / 256d * (to - from);
}

inline color[256] genLinearClut(color c1, color c2)
{
    weights = genSteps(0d, 1d);
    return Weights2Clut(weights, c1, c2);
}

inline color[256] genLogarithmicClut(double from, double to, color c1, color c2)
{
    steps = genSteps(from, to);
    weights = (log(steps) - log(from)) / (log(to) - log(from));
    return Weights2Clut(weights, c1, c2);
}

inline color[256] genExponentialClut(double from, double to, color c1, color c2)
{
    steps = genSteps(from, to);
    weights = (exp(steps) - exp(from)) / (exp(to) - exp(from));
    return Weights2Clut(weights, c1, c2);
}

inline color[256] genAlternatingClut(color c1, color c2)
{
    return with {
        ( . <= [i] <= . step [2]) : c1;
    } : genarray([256], c2);
}

/*
 * h_in is the hue in degrees [0:360]
 * s_in is the saturation in % [0:100]
 * b_in is the brightness in % [0:100]
 */
inline color Hsb2Rgb(int h_in, int s_in, int b_in)
{
    c = black();

    if (b_in == 0)
        c = black();
    else if (b_in == 100 && s_in == 0)
        c = white();
    else if (s_in == 0)
        c = newColor(b_in, b_in, b_in);
    else
    {
        h = tod(h_in) / 60d;
        s = tod(s_in) / 100d;
        b = tod(b_in) / 100d;

        i = toi(h) % 6;
        f = h - tod(i);

        if ((i % 2) == 0)
            f = 1d - f;

        m = b * (1d - s);
        n = b * (1d - s * f);

        b = toi(b * 255d);
        m = toi(m * 255d);
        n = toi(n * 255d);

        if (0 == i)
            c = newColor(b, n, m);
        else if (1 == i)
            c = newColor(n, b, m);
        else if (2 == i)
            c = newColor(m, b, n);
        else if (3 == i)
            c = newColor(m, n, b);
        else if (4 == i)
            c = newColor(n, m, b);
        else if (5 == i)
            c = newColor(b, m, n);
    }

    return c;
}

inline color[d:shp] Hsb2Rgb(int[d:shp] h, int s, int b)
{
    return { iv -> Hsb2Rgb(h[iv], s, b) | iv < shp };
}

inline color[d:shp] Hsb2Rgb(int[d:shp] h, int[d:shp] s, int[d:shp] b)
{
    return { iv -> Hsb2Rgb(h[iv], s[iv], b[iv]) | iv < shp };
}

/******************************************************************************
 *
 * Binary operations.
 *
 ******************************************************************************/

inline color +(color a, color b)
{
    r1, g1, b1 = rgb(a);
    r2, g2, b2 = rgb(b);
    return newColor(r1 + r2, g1 + g2, b1 + b2);
}

inline color[d:shp] + (color[d:shp] a, color[d:shp] b)
{
    return { iv -> a[iv] + b[iv] | iv < shp };
}

inline color -(color a, color b)
{
    r1, g1, b1 = rgb(a);
    r2, g2, b2 = rgb(b);
    return newColor(r1 - r2, g1 - g2, b1 - b2);
}

inline color[d:shp] -(color[d:shp] arr, color[d:shp] b)
{
    return { iv -> a[iv] - b[iv] | iv < shp };
}

inline color *(color c, double x)
{
    r, g, b = rgb(a);
    return newColor(toi(tod(r) * x), toi(tod(b) * x), toi(tod(b) * x));
}

inline color[d:shp] *(color[d:shp] c, double x)
{
    return { iv -> c[iv] * x | iv < shp };
}

/******************************************************************************
 *
 * Color constants.
 *
 ******************************************************************************/

inline color black()
{
    return (color)[0,0,0];
}

inline color white()
{
    return (color)[255,255,255];
}

inline color red()
{
    return (color)[255,0,0];
}

inline color green()
{
    return (color)[0,255,0];
}

inline color blue()
{
    return (color)[0,0,255];
}
