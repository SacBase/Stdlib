module Quaternion;

export all;

typedef double[4] quaternion;

/******************************************************************************
 *
 * Array properties.
 *
 * @note The definition of `dim` and `shape` for user-defined types may not use
 * type patterns, as type patterns rely on the existence of these functions
 * for user-defined types since the primitives `_dim_A_` and `_shape_A_`
 * are not defined for user-defined types.
 *
 ******************************************************************************/

inline int dim(quaternion[*] arr)
{
    return Array::dim((double[+])arr) Array::- 1;
}

inline int[.] shape(quaternion[*] arr)
{
    return Array::drop([Array::-1], Array::shape((double[+])arr));
}

inline quaternion[i:ishp] sel(int[o] idx, quaternion[o:oshp,i:ishp] arr)
    | _all_V_(_le_SxV_(0, idx)), _all_V_(_lt_VxV_(idx, oshp))
{
    return (quaternion[*])Array::sel(idx, (double[*])arr);
}

inline quaternion[d:shp] sel(int idx, quaternion[n,d:shp] arr)
    | _le_SxS_(0, idx), _lt_SxS_(idx, n)
{
    return arr[[idx]];
}

/******************************************************************************
 *
 * Type conversions.
 *
 ******************************************************************************/

inline quaternion[d:shp] toq(double[d:shp,4] arr)
{
    return (quaternion[*])arr;
}

inline quaternion[d:shp] toq(int[d:shp,4] arr)
{
    return (quaternion[*])Array::tod(arr);
}

inline double[d:shp,4] tod(quaternion[d:shp] arr)
{
    return (double[+])arr;
}

/******************************************************************************
 *
 * Binary operations on quaternions.
 *
 ******************************************************************************/

inline quaternion[d:shp] +(double a, quaternion[d:shp] b)
{
    return (quaternion[*])(a Array::+ (double[+])b);
}

inline quaternion[d:shp] +(quaternion[d:shp] a, double b)
{
    return (quaternion[*])((double[+])a Array::+ b);
}

inline quaternion[d:shp] +(quaternion[d:shp] a, quaternion[d:shp] b)
{
    return (quaternion[*])((double[+])a Array::+ (double[+])b);
}

/******************************************************************************/

inline quaternion *(quaternion a, quaternion b)
{
    ad = (double[4])a;
    ad0 = Array::sel([0], ad);
    ad1 = Array::sel([1], ad);
    ad2 = Array::sel([2], ad);
    ad3 = Array::sel([3], ad);

    bd = (double[4])b;
    bd0 = Array::sel([0], bd);
    bd1 = Array::sel([1], bd);
    bd2 = Array::sel([2], bd);
    bd3 = Array::sel([3], bd);

    return (quaternion)[
        ad0 Array::* bd0 Array::- ad1 Array::* bd1 Array::- ad2 Array::* bd2 Array::- ad3 Array::* bd3,
        ad0 Array::* bd1 Array::+ ad1 Array::* bd0 Array::+ ad2 Array::* bd3 Array::- ad3 Array::* bd2,
        ad0 Array::* bd2 Array::- ad1 Array::* bd3 Array::+ ad2 Array::* bd0 Array::+ ad3 Array::* bd1,
        ad0 Array::* bd3 Array::+ ad1 Array::* bd2 Array::- ad2 Array::* bd1 Array::+ ad3 Array::* bd0
    ];
}

inline quaternion[d:shp] *(quaternion a, quaternion[d:shp] b)
{
    return { iv -> a * b[iv] | iv < shp };
}

inline quaternion[d:shp] *(quaternion[d:shp] a, quaternion b)
{
    return { iv -> a[iv] * b | iv < shp };
}

inline quaternion[d:shp] *(quaternion[d:shp] a, quaternion[d:shp] b)
{
    return { iv -> a[iv] * b[iv] | iv < shp };
}
