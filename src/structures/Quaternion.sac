module Quaternion;

#define OVERLOAD dim,shape,sel,tod,+,*,-
use Array: all except { OVERLOAD };
import Array: { OVERLOAD };

export all;

typedef double[4] quaternion;

/******************************************************************************
 *
 * Array properties.
 *
 * @note These functions may not use type patterns, as type patterns rely
 * on the existence of these functions.
 *
 ******************************************************************************/

inline int dim(quaternion[*] arr)
{
    return dim((double[+])arr) - 1;
}

inline int[.] shape(quaternion[*] arr)
{
    return drop([-1], shape((double[+])arr));
}

inline quaternion[*] sel(int[.] idx, quaternion[*] arr)
{
    return (quaternion[*])((double[*])arr)[idx];
}

/******************************************************************************
 *
 * Type conversions.
 *
 ******************************************************************************/

inline quaternion[d:shp] toq(double[d:shp,4] arr)
{
    return (quaternion[*])arr;
}

inline quaternion[d:shp] toq(int[d:shp,4] arr)
{
    return (quaternion[*])tod(arr);
}

inline double[d:shp,4] tod(quaternion[d:shp] arr)
{
    return (double[+])arr;
}

/******************************************************************************
 *
 * Binary operations on quaternions.
 *
 ******************************************************************************/

inline quaternion[d:shp] +(double a, quaternion[d:shp] b)
{
    return (quaternion[*])(a + (double[+])b);
}

inline quaternion[d:shp] +(quaternion[d:shp] a, double b)
{
    return (quaternion[*])((double[+])a + b);
}

inline quaternion[d:shp] +(quaternion[d:shp] a, quaternion[d:shp] b)
{
    return (quaternion[*])((double[+])a + (double[+])b);
}

/******************************************************************************/

inline quaternion *(quaternion a, quaternion b)
{
    ad = (double[4])a;
    bd = (double[4])b;
    return (quaternion)[ad[0]*bd[0] - ad[1]*bd[1] - ad[2]*bd[2] - ad[3]*bd[3],
                        ad[0]*bd[1] + ad[1]*bd[0] + ad[2]*bd[3] - ad[3]*bd[2],
                        ad[0]*bd[2] - ad[1]*bd[3] + ad[2]*bd[0] + ad[3]*bd[1],
                        ad[0]*bd[3] + ad[1]*bd[2] - ad[2]*bd[1] + ad[3]*bd[0]];
}

inline quaternion[d:shp] *(quaternion a, quaternion[d:shp] b)
{
    return { iv -> a * b[iv] | iv < shp };
}

inline quaternion[d:shp] *(quaternion[d:shp] a, quaternion b)
{
    return { iv -> a[iv] * b | iv < shp };
}

inline quaternion[d:shp] *(quaternion[d:shp] a, quaternion[d:shp] b)
{
    return { iv -> a[iv] * b[iv] | iv < shp };
}
