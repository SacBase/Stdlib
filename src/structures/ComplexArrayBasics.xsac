module ComplexArrayBasics;

use ComplexBasics: { complex };

#define OVERLOADS dim,shape,sel,reshape,genarray,modarray
use Array: all except { OVERLOADS };
import Array: { OVERLOADS };

export all;

#include "Templates.mac"

/******************************************************************************
 *
 * @fn int dim( complex[*] A)
 *
 * @brief Yields an array's dimensionality (rank).
 *
 ******************************************************************************/
inline
int dim( complex[*] A)
{
  d = dim( (double[+])A);
  return d - 1;
}

/******************************************************************************
 *
 * @fn int[.] shape( complex[*] A)
 *
 * @brief Yields an array's shape vector.
 *
 ******************************************************************************/
inline
int[.] shape( complex[*] A)
{
  shp = shape( (double[+])A);
  return drop( [-1], shp);
}

/******************************************************************************
 *
 * @fn complex[d:shp] sel( int[vlen] idx, complex[vlen:vshp,d:shp] A)
 *
 * @brief Generalizes selections for scalar indices.
 *
 ******************************************************************************/
inline
complex[d:shp] sel( int[vlen] idx, complex[vlen:vshp,d:shp] A)
  | all( 0 <= idx), all( idx < vshp)
{
  v = ((double[+])A)[ idx];
  return (complex[*])v;
}

inline
complex[d:shp] sel( int idx, complex[n,d:shp] A)
  | 0 <= idx, idx < n
{
  return sel( [idx], A);
}

/******************************************************************************
 *
 * @fn double[d:shp] norm( complex[d:shp] A)
 *
 * @brief Yields an array of norms.
 *
 ******************************************************************************/
inline
double[d:shp] norm( complex[d:shp] A)
{
  return { iv -> ComplexBasics::norm( A[ iv]) | iv < shp };
}

/******************************************************************************
 *
 * @fn double[d:shp] normSq( complex[d:shp] A)
 *
 * @brief Yields an array of normSq.
 *
 ******************************************************************************/
inline
double[d:shp] normSq( complex[d:shp] A)
{
  return { iv -> ComplexBasics::normSq( A[ iv]) | iv < shp };
}

/******************************************************************************
 *
 * @fn complex[d:shp] reshape( int[d] shp, complex[o:oshp] A)
 *
 * @brief Creates a new array with identical data vector but new shape,
 *        provided the length of the data vector matches the product of
 *        the new shape vector.
 *
 ******************************************************************************/
inline
complex[d:shp] reshape( int[d] shp, complex[o:oshp] A)
  | all( 0 <= shp), prod( shp) == prod( oshp)
{
  v = reshape( shp ++ [2], (double[*])A);
  return (complex[*])v;
}

/******************************************************************************
 *
 * @fn complex[n:shp,m:vshp] genarray( int[n] shp, complex[m:vshp] val)
 *
 * @brief Generates a new array from the given shape and default value.
 *
 ******************************************************************************/
inline
complex[n:shp,m:vshp] genarray( int[n] shp, complex[m:vshp] val)
{
  return { iv -> val | iv < shp };
}

/******************************************************************************
 *
 * @fn complex[o:outer,i:inner] modarray( complex[o:outer,i:inner] A,
 *                                        int[o] idx, complex[i:inner] val)
 *
 * @brief Modifies the element of array at position idx.
 *
 ******************************************************************************/
inline
complex[o:outer,i:inner] modarray( complex[o:outer,i:inner] A,
                                   int[o] idx, complex[i:inner] val)
  | all( 0 <= idx), all( idx < outer)
{
  res = with {
          (idx <= iv <= idx) : val;
        } : modarray( A);
  return res;
}

inline
complex[n,d:shp] modarray( complex[n,d:shp] A, int idx, complex[d:shp] val)
  | 0 <= idx, idx < n
{
  return modarray( A, [idx], val);
}
